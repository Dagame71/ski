<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- PWA / Meta per dispositivi Apple -->
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Ski-Zag!">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-orientation" content="portrait">

    <!-- Registrazione del Service Worker -->
    <script>
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("service-worker.js")
          .then(() => console.log("Service Worker registrato!"))
          .catch(error => console.log("Errore nel Service Worker:", error));
      }
    </script>

    <meta charset="UTF-8">
    <!-- Disabilita pinch-to-zoom / doppio tap -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ski-Zag! World Cup</title>

    <!-- =====================================================
         STILI CSS
         ===================================================== -->
    <style>
      /* -------------------------------
         Stili di base e layout generale
      ------------------------------- */
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        font-family: "Helvetica Neue", Arial, sans-serif;
        background: #c4d3fc;
        margin-top: 0px;
      }
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .container {
        position: relative;
        width: 90%;
        max-width: 90vw;
        aspect-ratio: 300 / 520;
        background: #e1dffc url("sfondo.png") no-repeat center center;
        background-size: cover;
        border: 0px solid #ffffff;
        border-radius: 10px;
        margin-top: 10px;
        box-sizing: border-box;
        overflow: hidden;
      }
      canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        cursor: crosshair;
      }
#start-ring {
  display: none; 
  position: absolute;
  width: 40px;              /* Regola la dimensione in base alla tua grafica */
  height: 40px;
  border: 4px solid yellow; /* Bordo giallo */
  border-radius: 50%;
  pointer-events: none;     /* L'anello non intercetta eventi */
  transform: translate(-50%, -50%); /* Per centrare il div sul punto */
  animation: blink 1s infinite;
  z-index: 10;              /* Assicurati che stia sopra il canvas */
}

      /* -------------------------------
         Canvas per l'effetto neve
      ------------------------------- */
      #snowCanvas {
        position: fixed; /* Copre l'intero schermo */
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        pointer-events: none; /* La neve non intercetta eventi */
        z-index: 5; /* Layer intermedio */
      }

      /* -------------------------------
         Bottoni (stile generale)
      ------------------------------- */
      button {
        border: none !important;
        outline: none;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.3);
        box-shadow: 
          inset 1px 1px 2px rgba(255, 255, 255, 0.8),
          inset -1px -1px 2px #434d74,
          1px 1px 2px #434d74;
        padding: 6px 8px;
        transition: all 0.2s ease-in-out;
      }
      button:hover {
        background: rgba(255, 255, 255, 0.5);
        box-shadow: 
          inset 1px 1px 3px rgba(255, 255, 255, 0.8),
          inset -1px -1px 3px #434d74,
          2px 2px 4px #434d74;
      }

      /* -------------------------------
         Posizionamento dei bottoni fissi
      ------------------------------- */
      #sameTrack,
      #replayButton {
        position: absolute;
        z-index: 9999;
        bottom: 2%;
        left: 3%;
      }
      #quit {
        position: absolute;
        z-index: 9999;
        top: 2%;
        left: 3%;
      }
      #chronoButton {
        position: absolute;
        z-index: 9999;
        top: 2%;
        right: 3%;
      }
      /* Bottone Blind Mode */
      #blindToggle {
        font-size: 0.9em;
        position: absolute;
        z-index: 9999;
        bottom: 2%;
        left: 85%;
        cursor: pointer;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.3);
        box-shadow: inset 1px 1px 2px rgba(255, 255, 255, 0.8),
                    inset -1px -1px 2px #434d74,
                    1px 1px 2px #434d74;
        padding: 6px 8px;
        transition: all 0.2s ease-in-out;
      }
      #blindToggle:hover {
        background: rgba(255, 255, 255, 0.5);
        box-shadow: 
          inset 1px 1px 3px rgba(255, 255, 255, 0.8),
          inset -1px -1px 3px #434d74,
          1px 1px 3px #434d74;
      }

      /* -------------------------------
         Contenitore informazioni (messaggi)
      ------------------------------- */
      .info-container {
        width: 90vw;
        max-width: 500px;
        margin: 2px auto;
        padding: 1px;
        margin-top: -3px;
        border: 0px solid #9cc1e2;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.2);
        display: flex;
        box-shadow: 
          inset 1px 1px 3px rgba(0, 0, 0, 0.2),
          inset -1px -1px 3px #9cc1e2;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        z-index: 9999;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-touch-callout: none;
      }
      /* Unica riga di testo per tutti i messaggi */
      #infoLine {
        margin: 5px 0;
        font-weight: bold;
        font-size: 1.2em;
        min-height: 20px;
        text-align: center;
        color: black;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-touch-callout: none;
      }

      /* -------------------------------
         Animazioni
      ------------------------------- */
      @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0; }
      }
      .record {
        animation: blink 0.5s ease-in-out 6;
      }
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      /* -------------------------------
         Overlay generici
      ------------------------------- */
      .overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 10005;
        display: flex;
        justify-content: center;
        align-items: center;
        animation: fadeIn 0.3s ease;
      }
      .hidden {
        display: none;
      }
      .overlay-content {
        background-image: url("backpopup.png");
        background-repeat: no-repeat;
        background-position: center;
        background-size: cover;
        background-color: #fff;
        border-radius: 12px;
        padding: 2%;
        width: 80%;
        max-width: 300px;
        box-sizing: border-box;
        position: relative;
        text-align: center;
        color: #333;
        box-shadow: inset 4px 4px 2px rgba(175, 219, 245, 0.8),
                    inset -4px -4px 2px rgba(255, 255, 255, 0.8);
      }
      .overlay-text {
        font-size: 14px;
        line-height: 1.3;
      }
      .popup-button-container {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 15px;
      }
      #popupOkButton {
        background: #007bff;
        color: #fff;
        border: none;
        border-radius: 8px;
        padding: 0.5em 1em;
        font-size: 1em;
        cursor: pointer;
        text-align: center;
        display: inline-block;
      }
      #popupOkButton:hover {
        background: #bdc9fb;
      }
      /* Bottone per chiudere l'overlay */
      #closeOverlay {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: #8fa2f7;
        font-size: 0.875em;
        padding: 0.5em 1em;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }
      #closeOverlay:hover {
        background-color: #bdc9fb;
      }
      /* Animazione lampeggiante */
      @keyframes blinker {
        50% { opacity: 0; }
      }
      .blinking {
        animation: blinker 1s linear infinite;
      }

      /* -------------------------------
         Leaderboard & Classifica
      ------------------------------- */
      .leaderboard-container {
        display: block;
        width: 100%;
        margin-top: 10px;
      }
      .leaderboard {
        width: 100%;
        margin: 0 auto;
      }
      .leaderboard h2 {
        text-align: center;
        margin: 10px 0;
        font-size: 1.2em;
      }
      ol {
        border: 1px solid #999bf2;
        border-radius: 5px;
        list-style: decimal inside;
        min-height: 100px;
        padding: 10px;
        margin: 0;
      }
      li {
        padding: 5px 0;
        font-size: 1em;
      }
#pointsLeaderboardBody tr:first-child {
  font-weight: bold !important;
}
      /* -------------------------------
         Slider / Tutorial
      ------------------------------- */
      .intro-overlay {}
      .slide-content {
        margin-bottom: 20px;
        line-height: 1.4;
        font-size: 1em;
      }
      .slide-title {
        margin-top: 20;
        margin-bottom: 10px;
        font-size: 1.5em;
      }
      .slides-nav {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 15px;
      }
      .slides-nav .nav-button {
        background: #007bff;
        color: #fff;
        border: none;
        border-radius: 8px;
        padding: 0.5em 1em;
        font-size: 1em;
        cursor: pointer;
      }
      .slides-nav .nav-button:disabled {
        background: #bdc9fb;
        cursor: not-allowed;
      }
      .tutorial-dots {
        display: flex;
        justify-content: center;
        gap: 8px;
        margin: 10px 0;
      }
      .dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #ffffff;
        cursor: pointer;
        transition: background 0.3s;
      }
      .dot.active {
        background: #007bff;
      }
      .close-button {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: #8fa2f7;
        font-size: 0.875em;
        padding: 0.5em 1em;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }
      .close-button:hover {
        background-color: #bdc9fb;
      }

      /* -------------------------------
         Tabella del Campionato
      ------------------------------- */
      .champ-table {
        margin: 15px 0;
        border: 1px solid #999bf2;
        border-radius: 8px;
        width: 100%;
        overflow: hidden;
        text-align: left;
      }
      .champ-table table {
        width: 100%;
        border-collapse: collapse;
      }
      .champ-table th,
      .champ-table td {
        padding: 8px;
        border-bottom: 1px solid #999bf2;
        font-size: 1em;
      }
      .champ-table th {
        background: #8fa2f7;
        font-weight: bold;
        color: white;
      }
      .champ-table tr:last-child td {
        border-bottom: none;
      }
#leaderboardList li {
  text-align: left;
}
      
      /* -------------------------------
         Input per i nomi dei giocatori
      ------------------------------- */
      .player-name-input {
        background: #ffffff;
        border: 1px solid #bdc9fb;
        border-radius: 16px;
        padding: 10px;
        width: 80%;
        margin-bottom: 8px;
        box-shadow: inset 3px 3px 4px rgba(0, 0, 0, 0.2),
                    inset -3px -3px 4px rgba(255, 255, 255, 0.7);
        outline: none;
        font-size: 1em;
        transition: all 0.2s ease-in-out;
      }
      .player-name-input:focus {
        background: #ffffff;
        box-shadow: inset 2px 2px 4px rgba(0, 0, 0, 0.3),
                    inset -2px -2px 4px rgba(255, 255, 255, 0.8);
      }
      
      /* -------------------------------
         Bottoni finali (per la gara)
      ------------------------------- */
      .end-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px;
      }
      .end-buttons button {
        background: #007bff;
        color: #fff;
        border: none;
        border-radius: 8px;
        padding: 0.5em 1em;
        font-size: 1em;
        cursor: pointer;
      }
      .end-buttons button:hover {
        background-color: #0056b3;
      }
      
      /* -------------------------------
         Posizionamento dei bottoni in alto e in basso
      ------------------------------- */
      .top-buttons {
        pointer-events: none;
        position: absolute;
        top: 1%;
        left: 0;
        right: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 5%;
        z-index: 10;
      }
      .top-buttons button {
        pointer-events: auto;
        position: static;
        width: 30%;
        max-width: 35px;
        aspect-ratio: 1 / 1;
        padding: 4px 6px;
      }
      .bottom-buttons {
        position: absolute;
        bottom: 1.15%;
        left: 0;
        right: 0;
        display: flex;
        justify-content: center;
        gap: 10px;
        align-items: center;
        z-index: 10;
      }
      .bottom-buttons button {
        position: static;
        width: 30%;
        max-width: 35px;
        aspect-ratio: 1 / 1;
        padding: 4px 6px;
      }

      /* -------------------------------
         Media Queries per layout responsive
      ------------------------------- */
      @media (min-width: 600px) {
        .container {
          max-width: 900px; /* Aumentato da 600px a 900px */
        }
        #replayButton {
          left: 3%;
        }
        #blindToggle {
          left: 90%;
        }
      }
      @media (min-width: 768px) {
        .container {
          max-width: 500px !important;
        }
      }
      
      /* -------------------------------
         Logo in basso
      ------------------------------- */
      .bottom-space {
        width: 100%;
        height: 80px;
        background: url("logo.png") no-repeat center bottom;
        background-size: contain;
        flex-shrink: 0;
      }
      @media (max-height: 700px) {
        .bottom-space {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <!-- Elemento per la calibrazione (misurazione in pollici) -->
    <div id="calibrationTest" style="width:1in; position:absolute; left:-1000px; top:-1000px;"></div>
    
    <!-- Canvas per l'effetto neve (a pagina intera) -->
    <canvas id="snowCanvas" class="hidden"></canvas>
    
    <!-- Container principale del gioco -->
    <div class="container">
      <canvas id="canvas"></canvas>
<div id="start-ring"></div>
      <!-- Bottone "Same Run" (nascosto, usato in modalit√† World Cup) -->
      <button id="sameTrack" title="Same Run" hidden>üîÅ</button>
      
      <!-- Bottoni in alto: Quit e Chrono -->
      <div class="top-buttons">
        <button id="quit" title="Close">
          <img src="close.png" alt="Close" style="width:19px; height:19px;">
        </button>
        <button id="chronoButton" title="Chrono">
          <img src="stopwatch.png" alt="Chrono" style="width:19px; height:19px;">
        </button>
      </div>
      
      <!-- Bottoni in basso: Replay e Blind Toggle -->
      <div class="bottom-buttons">
        <button id="replayButton" title="Replay">
          <img src="replay.png" alt="Replay" style="width:19px; height:19px;">
        </button>
        <button id="blindToggle" title="Toggle Blind Mode">
          <img id="blindIcon" src="view.png" alt="View Mode" style="width:19px; height:19px;">
        </button>
      </div>
      
      <!-- Overlay CHRONO (Top 5 e Points Standings) -->
      <div id="chronoOverlay" class="overlay hidden">
        <div class="overlay-content">
          <button id="closeOverlay">X</button>
          <div class="leaderboard-container">
            <div class="leaderboard">
              <h2>Top 5</h2>
              <ol id="leaderboardList"></ol>
            </div>
          </div>
          <!-- Sezione per la classifica punti -->
          <div class="leaderboard-container">
            <div class="leaderboard">
              <h2>Points Standings</h2>
              <div class="champ-table">
                <table id="pointsLeaderboardTable">
                  <thead>
                    <tr>
                      <th>Player</th>
                      <th>Points</th>
                    </tr>
                  </thead>
                  <tbody id="pointsLeaderboardBody">
                    <!-- Dati inseriti dinamicamente -->
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Contenitore dei messaggi -->
    <div class="info-container">
      <p id="infoLine"></p>
    </div>
    
    <!-- Overlay INTRO / SLIDES -->
    <div id="slidesOverlay" class="overlay hidden">
      <div id="slidesContent" class="overlay-content intro-overlay">
        <button id="closeIntroOverlay" class="close-button">X</button>
        <!-- Il contenuto introduttivo verr√† inserito dinamicamente -->
      </div>
    </div>
    
    <!-- Overlay per annunci e classifiche (championship) -->
    <div id="champOverlay" class="overlay hidden">
      <div id="champContent" class="overlay-content"></div>
    </div>
    
    <!-- =====================================================
         SCRIPT: VARIABILI, FUNZIONI E GESTIONE EVENTI
         ===================================================== -->
    <script>
      /* ==============================================
         VARIABILI GLOBALI E IMPOSTAZIONI
      ============================================== */
      const PATH_LENGTH_SCALING = 500;
      const PENALTY_WEIGHT = 0.5;
      const BORDER_THRESHOLD = 5; // Considera "al bordo" se la traiettoria sta entro 5px dal bordo
      const MIN_VERTICAL_GAP = 30; // Distanza minima in pixel tra bandiere

      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      // Unifica tutti i messaggi in un solo elemento <p>
      const infoLine = document.getElementById("infoLine");
      let mainLabel = "";
      function setMainLabel(label) {
        // Sostituisce ogni "‚è∞" con l'immagine del cronometro
        const replacedText = label.replaceAll(
          "‚è∞",
          '<img src="stopwatch.png" alt="Stopwatch" style="position: relative; top:-2px; width:18px; height:18px; vertical-align:middle; margin-right:4px;">'
        );
        mainLabel = replacedText;
        infoLine.innerHTML = replacedText;
        if (replacedText.includes("Double-tap here to start!")) {
          infoLine.classList.add("blinking");
        } else {
          infoLine.classList.remove("blinking");
        }
      }
      function showTemporaryMessage(msg, duration = 2000) {
        const oldLabel = mainLabel;
        infoLine.textContent = msg;
        infoLine.classList.remove("record");
        setTimeout(() => {
          setMainLabel(oldLabel);
        }, duration);
      }
      function showTemporaryMessageHtml(html, duration = 2000) {
        const oldLabel = mainLabel;
        infoLine.innerHTML = html;
        infoLine.classList.remove("record");
        setTimeout(() => {
          setMainLabel(oldLabel);
        }, duration);
      }

      // Bottoni di controllo e overlay
      const sameTrackButton = document.getElementById("sameTrack");
      const replayButton = document.getElementById("replayButton");
      const chronoButton = document.getElementById("chronoButton");
      const chronoOverlay = document.getElementById("chronoOverlay");
      const closeOverlay = document.getElementById("closeOverlay");
      const slidesOverlay = document.getElementById("slidesOverlay");
      const slidesContent = document.getElementById("slidesContent");
      const champOverlay = document.getElementById("champOverlay");
      const champContent = document.getElementById("champContent");

      // Variabili di gioco e stato
      let treeHits = {};
      let bestTimes = [];
      let currentTrack = null;
      let gates = [];
      let trees = [];
      let pointsPath = [];
      let drawing = false;
      let startTime = 0;
      let intersectedGates = new Set();
      let participants = [];
      let championScores = {};
      let currentIndex = 0;
      let attemptCount = 0;
      let raceNumber = 1;
      let runNumber = 1;
      const CHAMPION_POINTS = [9, 7, 5, 3, 1];
      let hardMode = true;
      let slidesIntro = [];
      let currentSlideIndex = 0;
      let didFinishOrFailThisRun = false;
      let falseStartCount = 0;
      let weatherState = null; // "nn", "pn", "mn", "nf"
      let snowIntensity = 0;
      let showSnow = false;
      let globalWind = Math.random() * 1 - 0.5;
      let replaySnowState = false;
      // Variabili per gestione touch/long press
      let longPressTimer = null;
      const LONG_PRESS_DURATION = 700; // 700 ms
      const LONG_PRESS_MOVE_THRESHOLD = 10; // in pixel
      let touchStartPos = { x: 0, y: 0 };
      let touchMoved = false;
      let expectedGate = 1;
      // Impostazioni di partenza e arrivo
      let startPoint = { x: 150, y: 30 };
      let finishRect = { x: 130, y: 490, width: 40, height: 10 };
      let lastSnowActive = false;
      let outPenaltyCount = 0;
      let isOut = false;
      // Variabili per modalit√† editor
      let interactionInProgress = false;
      let editingMode = false;
      let draggedElement = null;
      let isDragging = false;
      let isLongPressActive = false;
      let pulseTime = 0;
      const PULSE_SPEED = 0.05; // Velocit√† oscillazione
let autoPopupOpened = false;
let lastRunHighlight = null;
      /* ==============================================
         FUNZIONE DI INTERPOLAZIONE PER IL BORDO
      ============================================== */
      function checkInterpolationForBorder(p1, p2) {
        const stepLength = 2;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const distance = Math.hypot(dx, dy);
        const steps = Math.ceil(distance / stepLength);
        for (let i = 1; i <= steps; i++) {
          const t = i / steps;
          const ix = p1.x + t * dx;
          const iy = p1.y + t * dy;
          if (ix < BORDER_THRESHOLD || ix > canvas.width - BORDER_THRESHOLD) {
            return true;
          }
        }
        return false;
      }

      /* ==============================================
         RESIZE DEL CANVAS (RESPONSIVO)
      ============================================== */
      function resizeCanvas() {
        const container = document.querySelector(".container");
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        startPoint = { x: canvas.width / 2, y: (30 / 520) * canvas.height };
        finishRect = {
          x: canvas.width / 2 - 20,
          y: canvas.height - 50,
          width: 40,
          height: 10
        };
      }

      /* ==============================================
         CLEAR DEL CANVAS
      ============================================== */
      function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      /* ==============================================
         Calibrazione (misura in pollici)
      ============================================== */
      window.addEventListener("load", () => {
        const cal = document.getElementById("calibrationTest");
        window.conversionFactor = cal.offsetWidth / 96;
      });

      /* ==============================================
         Impostazione delle risorse (icone, immagini)
      ============================================== */
      const gateIcons = {
        red: new Image(),
        blue: new Image()
      };
      gateIcons.red.src = "red_gate.svg";
      gateIcons.blue.src = "blue_gate.svg";
      const startIcon = new Image();
      startIcon.src = "start.svg";
      const treeImg = new Image();
      treeImg.src = "tree.svg";
      treeImg.onload = () => {
        console.log("Immagine dell'albero caricata con successo.");
        if (currentTrack) {
          drawTrack(currentTrack);
        }
      };
      treeImg.onerror = () => {
        console.error("Errore nel caricamento di tree.svg");
      };

      /* ==============================================
         FUNZIONI METEO
      ============================================== */
      function chooseWeatherState(prevState) {
        const r = Math.random() * 100;
        switch (prevState) {
          case "nn":
            if (r < 50) return "nn";
            else if (r < 80) return "pn";
            else if (r < 95) return "mn";
            else return "nf";
          case "pn":
            if (r < 25) return "nn";
            else if (r < 65) return "pn";
            else if (r < 90) return "mn";
            else return "nf";
          case "mn":
            if (r < 20) return "nn";
            else if (r < 50) return "pn";
            else if (r < 80) return "mn";
            else return "nf";
          case "nf":
            if (r < 20) return "nn";
            else if (r < 60) return "pn";
            else if (r < 80) return "mn";
            else return "nf";
          default:
            return "nn";
        }
      }
      function applyWeatherState(state) {
        if (state === "nn") {
          snowIntensity = 0;
        } else if (state === "pn") {
          snowIntensity = 300;
        } else if (state === "mn") {
          snowIntensity = 1000;
        } else if (state === "nf") {
          snowIntensity = 3250;
        }
        weatherState = state;
        return snowIntensity > 0;
      }

      /* ==============================================
         GESTIONE DELLA NEVE
      ============================================== */
      const snowCanvasElem = document.getElementById("snowCanvas");
      const snowCtx = snowCanvasElem.getContext("2d");
      let snowflakes = [];
      function initSnow() {
        snowflakes = [];
        for (let i = 0; i < snowIntensity; i++) {
          snowflakes.push({
            x: Math.random() * snowCanvasElem.width,
            y: Math.random() * snowCanvasElem.height,
            radius: Math.random() * 3 + 1,
            speedY: Math.random() * 0.5 + 0.5,
            speedX: Math.random() * 0.5 - 0.25
          });
        }
      }
      function updateSnow() {
        if (!showSnow) return;
        snowCtx.clearRect(0, 0, snowCanvasElem.width, snowCanvasElem.height);
        snowflakes.forEach((flake) => {
          flake.x += flake.speedX + globalWind;
          flake.y += flake.speedY;
          if (flake.y > snowCanvasElem.height) {
            flake.y = 0;
            flake.x = Math.random() * snowCanvasElem.width;
          }
          if (flake.x > snowCanvasElem.width) flake.x = 0;
          if (flake.x < 0) flake.x = snowCanvasElem.width;
          snowCtx.beginPath();
          snowCtx.arc(flake.x, flake.y, flake.radius, 0, Math.PI * 2);
          snowCtx.fillStyle = "white";
          snowCtx.fill();
        });
        requestAnimationFrame(updateSnow);
      }

      /* ==============================================
         GENERAZIONE DELLA PISTA
      ============================================== */
      function createTrackForRace(rn) {
        let gc = 8;
        if (rn === 2) gc = 10;
        if (rn === 3) gc = 6;
        const g = generateGates(gc);
        const t = generateTrees(g);
        return { gates: g, trees: t };
      }
      function generateGates(count) {
        const startWithRed = Math.random() < 0.5;
        let isRed = startWithRed;
        let arr = [];
        for (let i = 0; i < count; i++) {
          const dir = isRed ? 1 : -1;
          const x =
            isRed
              ? Math.random() * (canvas.width / 2 - 35) + canvas.width / 2
              : Math.random() * (canvas.width / 2 - 35) + 35;
          // La posizione y √® calcolata in modo differente per la World Cup
          const y = 100 + i * ((canvas.height - 160) / count);
          const color = isRed ? "red" : "blue";
          arr.push({
            x: x,
            y: y,
            color: color,
            number: i + 1, // Numero del gate
            line: {
              x1: x,
              y1: y,
              x2: x + dir * 200, // Valore fisso nella versione World Cup
              y2: y
            }
          });
          isRed = !isRed;
        }
        return arr;
      }
      function generateTrees(gArr) {
        const treeCount = Math.floor(Math.random() * 3) + 6;
        let arr = [];
        const margin = 30;
        const minGate = 50,
              minTree = 30,
              minFinish = 50,
              minStart = 40,
              minTop = 60;
        while (arr.length < treeCount) {
          const tx = margin + Math.random() * (canvas.width - 2 * margin);
          const ty = minTop + Math.random() * (canvas.height - minTop - margin);
          const closeGate = gArr.some((g) => Math.hypot(tx - g.x, ty - g.y) < minGate);
          const closeTrees = arr.some((t) => Math.hypot(tx - t.x, ty - t.y) < minTree);
          const closeFinish = isNearFinish(tx, ty, finishRect, minFinish);
          const closeStart = Math.hypot(tx - startPoint.x, ty - startPoint.y) < minStart;
          if (!closeGate && !closeTrees && !closeFinish && !closeStart) {
            arr.push({ x: tx, y: ty });
          }
        }
        return arr;
      }

      /* ==============================================
         DISEGNO DELLA PISTA E DEGLI ELEMENTI
      ============================================== */
      function drawTrack(track) {
        clearCanvas();
        gates = track.gates;
        trees = track.trees;
        intersectedGates = new Set();
        drawStartPoint();
        drawFinishArea();
        drawGates(gates);
        drawTrees(trees);
      }
      function drawStartPoint() {
        const iconWidth = (16 / 300) * canvas.width;
        const iconHeight = (16 / 520) * canvas.height;
        ctx.drawImage(
          startIcon,
          startPoint.x - iconWidth / 2,
          startPoint.y - iconHeight / 2,
          iconWidth,
          iconHeight
        );
      }
      function drawFinishArea() {
        const { x, y, width, height } = finishRect;
        const sq = width / 8;
        const rowCount = Math.floor(height / (width / 8));
        for (let row = 0; row < rowCount; row++) {
          for (let col = 0; col < 8; col++) {
            ctx.fillStyle = (row + col) % 2 === 0 ? "black" : "#F0F0F0";
            ctx.fillRect(x + col * sq, y + row * sq, sq, sq);
          }
        }
      }
      function drawGates(gArr) {
        gArr.forEach((g) => {
          // Se in modalit√† editor, disegna anche un alone pulsante (opzionale)
          if (editingMode) {
            ctx.save();
            const baseRadius = 14;
            const pulse = Math.sin(pulseTime) * 2;
            const radius = baseRadius + pulse;
            ctx.strokeStyle = "rgba(255, 255, 0, 0.4)";
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(g.x, g.y, radius, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.restore();
          }
          // Disegna l'icona del gate
          const icon = g.color === "red" ? gateIcons.red : gateIcons.blue;
const iconWidth = (16 / 300) * canvas.width * 1.05;
const iconHeight = (16 / 520) * canvas.height * 1.05;
ctx.drawImage(icon, g.x - iconWidth / 2, g.y - iconHeight / 2, iconWidth, iconHeight);
        });
      }
      function drawTrees(tArr) {
        if (!treeImg.complete) return; // Se l'immagine non √® ancora caricata, esci
        tArr.forEach((t) => {
          // Se in modalit√† editor, disegna anche un alone pulsante intorno all'albero
          if (editingMode) {
            ctx.save();
            const baseRadius = 14;
            const pulse = Math.sin(pulseTime) * 2;
            const radius = baseRadius + pulse;
            ctx.strokeStyle = "rgba(255, 255, 0, 0.6)";
            ctx.lineWidth = 6;
            ctx.beginPath();
            const treeWidth = (12 / 300) * canvas.width;
            const treeHeight = (20 / 520) * canvas.height;
            ctx.arc(t.x, t.y - treeHeight / 2, radius, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.restore();
          }
const treeWidth = (12 / 300) * canvas.width * 1.30;
const treeHeight = (20 / 520) * canvas.height * 1.30;
ctx.drawImage(treeImg, t.x - treeWidth / 2, t.y - treeHeight, treeWidth, treeHeight);
        });
      }
function positionStartRing() {
  // Se siamo in modalit√† editor, non mostrare l'anello
  if (editingMode) {
    const ring = document.getElementById("start-ring");
    if (ring) ring.style.display = "none";
    return;
  }
  const ring = document.getElementById("start-ring");
  if (!ring) return;
  ring.style.left = startPoint.x + "px";
  ring.style.top = startPoint.y + "px";
  ring.style.display = "block"; // Mostra l'anello solo se non siamo in editor
}

      /* ==============================================
         Animazione in Modalit√† Editor (pulsazione)
      ============================================== */
      function animate() {
        pulseTime += PULSE_SPEED;
        if (editingMode && currentTrack) {
          clearCanvas();
          drawTrack(currentTrack);
        }
        requestAnimationFrame(animate);
      }

      /* ==============================================
         GESTIONE EVENTI MOUSE / TOUCH (GAME e Editor)
      ============================================== */
      function getMouseCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const cx = e.touches ? e.touches[0].clientX : e.clientX;
        const cy = e.touches ? e.touches[0].clientY : e.clientY;
        return {
          x: ((cx - rect.left) / rect.width) * canvas.width,
          y: ((cy - rect.top) / rect.height) * canvas.height
        };
      }
      function isNearStartPoint(x, y) {
        return Math.hypot(x - startPoint.x, y - startPoint.y) <= (20 / 520) * canvas.height;
      }
      
      /* -------------------------------
         Gestione degli eventi in modalit√† GAME
      ------------------------------- */
      function handleMouseDownGame(e) {
        const { x, y } = getMouseCoords(e);
        if (!isNearStartPoint(x, y)) {
          falseStartCount++;
          if (falseStartCount === 1) {
            showTemporaryMessageHtml(
              '<span style="color:red;">False start!</span> <span style="color:black;">2nd attempt!</span>',
              1500
            );
          } else if (falseStartCount === 2) {
            showTemporaryMessageHtml(
              '<span style="color:red;">False start!</span> <span style="color:black;">Last attempt!</span>',
              1500
            );
          } else if (falseStartCount >= 3) {
            setMainLabel("Run failed due to consecutive false starts!");
            failAttempt("Run failed due to false starts.");
            falseStartCount = 0;
          }
          setTimeout(() => {
            if (isChallengeMode && challengeBestTime > 0) {
              setMainLabel(`Beat this time: ${formatTime(challengeBestTime)}`);
            }
          }, 2000);
          return;
        }
        falseStartCount = 0;
        outPenaltyCount = 0;
        isOut = false;
        drawing = true;
        pointsPath = [];
        startTime = performance.now();
        didFinishOrFailThisRun = false;
        // --- NUOVA LOGICA: Dopo lo start, il prossimo gate atteso √® il 1.
        expectedGate = 1;
        ctx.beginPath();
        pointsPath.push({ x, y, t: 0 });
        ctx.moveTo(x, y);
      }
      function handleMouseMoveGame(e) {
        if (!drawing) return;
        const { x, y } = getMouseCoords(e);
        let p1 = pointsPath[pointsPath.length - 1];
        let p2 = { x, y };
        if (p1 && checkInterpolationForBorder(p1, p2)) {
          if (!isOut) {
            outPenaltyCount++;
            isOut = true;
          }
        } else {
          isOut = false;
        }
        const now = performance.now() - startTime;
        pointsPath.push({ x, y, t: now });
  ctx.lineTo(x, y);
ctx.strokeStyle = "#a4b8eb";
ctx.lineWidth = (2 / 520) * canvas.height;
ctx.stroke();
        checkIntersections();
      }
      function handleMouseUpGame(e) {
        if (!drawing) return;
        drawing = false;
        if (!didFinishOrFailThisRun) {
          failAttempt("Run interrupted!");
        }
      }
      function handleTouchStartGame(e) {
        e.preventDefault();
        const { x, y } = getMouseCoords(e);
        if (!isNearStartPoint(x, y)) {
          showTemporaryMessage("You must start from the start point!", 1500);
          return;
        }
        falseStartCount = 0;
        outPenaltyCount = 0;
        isOut = false;
        drawing = true;
        pointsPath = [];
        startTime = performance.now();
        ctx.beginPath();
        pointsPath.push({ x, y, t: 0 });
        ctx.moveTo(x, y);
        didFinishOrFailThisRun = false;
        expectedGate = 1; // Dopo lo start, il prossimo gate atteso √® il 1.
      }
      function handleTouchMoveGame(e) {
        e.preventDefault();
        if (!drawing) return;
        const { x, y } = getMouseCoords(e);
        let p1 = pointsPath[pointsPath.length - 1];
        let p2 = { x, y };
        if (p1 && checkInterpolationForBorder(p1, p2)) {
          if (!isOut) {
            outPenaltyCount++;
            isOut = true;
          }
        } else {
          isOut = false;
        }
        const now = performance.now() - startTime;
        pointsPath.push({ x, y, t: now });
   ctx.lineTo(x, y);
ctx.strokeStyle = "#a4b8eb";
ctx.lineWidth = (2 / 520) * canvas.height;
ctx.stroke();
        checkIntersections();
      }
      function handleTouchEndGame(e) {
        e.preventDefault();
        if (!drawing) return;
        drawing = false;
        if (!didFinishOrFailThisRun) {
          failAttempt("Run interrupted!");
        }
      }

      /* -------------------------------
         Dispatcher: se editingMode √® attivo chiama le funzioni per l'editor,
         altrimenti quelle per il gioco.
      ------------------------------- */
      function handleMouseDown(e) {
        if (editingMode) {
          handleMouseDownEditor(e);
        } else {
          handleMouseDownGame(e);
        }
      }
      function handleMouseMove(e) {
        if (editingMode) {
          handleMouseMoveEditor(e);
        } else {
          handleMouseMoveGame(e);
        }
      }
      function handleMouseUp(e) {
        if (editingMode) {
          handleMouseUpEditor(e);
        } else {
          handleMouseUpGame(e);
        }
      }
      function handleTouchStart(e) {
        e.preventDefault();
        if (editingMode) {
          handleTouchStartEditor(e);
        } else {
          handleTouchStartGame(e);
        }
      }
      function handleTouchMove(e) {
        e.preventDefault();
        if (editingMode) {
          handleTouchMoveEditor(e);
        } else {
          handleTouchMoveGame(e);
        }
      }
      function handleTouchEnd(e) {
        e.preventDefault();
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;
        if (tapLength < 300 && tapLength > 0) {
          // eventuale doppio tap
        }
        lastTap = currentTime;
        if (editingMode) {
          handleTouchEndEditor(e);
        } else {
          handleTouchEndGame(e);
        }
      }
      // Listener per "touchcancel"
      canvas.addEventListener("touchcancel", handleTouchEnd, false);
      
      /* ==============================================
         FUNZIONI PER LA MODALIT√Ä EDITOR
         (handleMouseDownEditor, handleMouseMoveEditor, etc.)
         Rimangono invariate rispetto all'originale.
      ============================================== */
      function handleMouseDownEditor(e) {
        const { x, y } = getMouseCoords(e);
        longPressTimer = setTimeout(() => {
          if (!touchMoved && !interactionInProgress) {
            interactionInProgress = true;
            addTree(x, y);
            interactionInProgress = false;
          }
          longPressTimer = null;
        }, LONG_PRESS_DURATION);
        touchStartPos = { x, y };
        touchMoved = false;
      
        let foundG = findNearestGate(x, y, 20);
        if (foundG) {
          let g = gates[foundG.index];
          draggedElement = {
            type: "gate",
            index: foundG.index,
            oldX: g.x,
            oldY: g.y,
            offsetX: g.x - x,
            offsetY: g.y - y,
          };
          touchMoved = true;
          clearTimeout(longPressTimer);
          longPressTimer = null;
          return;
        }
      
        let foundT = findNearestTree(x, y, 20);
        if (foundT) {
          let t = trees[foundT.index];
          draggedElement = {
            type: "tree",
            index: foundT.index,
            oldX: t.x,
            oldY: t.y,
            offsetX: t.x - x,
            offsetY: t.y - y,
          };
          touchMoved = true;
          clearTimeout(longPressTimer);
          longPressTimer = null;
          return;
        }
      
        draggedElement = null;
      }
      
      function handleMouseMoveEditor(e) {
        if (!draggedElement) {
          const { x, y } = getMouseCoords(e);
          const dx = Math.abs(x - touchStartPos.x);
          const dy = Math.abs(y - touchStartPos.y);
          if (dx > LONG_PRESS_MOVE_THRESHOLD || dy > LONG_PRESS_MOVE_THRESHOLD) {
            touchMoved = true;
            clearTimeout(longPressTimer);
            longPressTimer = null;
          }
        } else {
          const { x, y } = getMouseCoords(e);
          const dragX = x + draggedElement.offsetX;
          const dragY = y + draggedElement.offsetY;
          if (draggedElement.type === "gate") {
            const gate = gates[draggedElement.index];
            const { minY, maxY } = getVerticalLimits(draggedElement.index);
            let newY = dragY;
            newY = Math.max(newY, minY);
            newY = Math.min(newY, maxY);
            gate.x = dragX;
            gate.y = newY;
            const dir = gate.color === "red" ? 1 : -1;
            gate.line.x1 = gate.x;
            gate.line.y1 = gate.y;
            gate.line.x2 = gate.x + dir * 200;
            gate.line.y2 = gate.y;
          } else if (draggedElement.type === "tree") {
            const tree = trees[draggedElement.index];
            tree.x = dragX;
            tree.y = dragY;
          }
          drawTrack(currentTrack);
        }
      }
      
      function handleMouseUpEditor(e) {
        if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
        if (!draggedElement) {
          interactionInProgress = false;
          return;
        }
        checkEditorConstraints(draggedElement);
        draggedElement = null;
        drawTrack(currentTrack);
        interactionInProgress = false;
      }
      
      function handleTouchStartEditor(e) {
        e.preventDefault();
        const { x, y } = getMouseCoords(e);
        isDragging = false;
        isLongPressActive = false;
        longPressTimer = setTimeout(() => {
          if (!touchMoved) {
            isLongPressActive = true;
            addTree(x, y);
          }
          longPressTimer = null;
        }, LONG_PRESS_DURATION);
        touchStartPos = { x, y };
        touchMoved = false;
        let foundG = findNearestGate(x, y, 20);
        if (foundG) {
          let g = gates[foundG.index];
          draggedElement = {
            type: "gate",
            index: foundG.index,
            oldX: g.x,
            oldY: g.y,
            offsetX: g.x - x,
            offsetY: g.y - y
          };
          touchMoved = true;
          clearTimeout(longPressTimer);
          longPressTimer = null;
          return;
        }
        let foundT = findNearestTree(x, y, 20);
        if (foundT) {
          let t = trees[foundT.index];
          draggedElement = {
            type: "tree",
            index: foundT.index,
            oldX: t.x,
            oldY: t.y,
            offsetX: t.x - x,
            offsetY: t.y - y
          };
          touchMoved = true;
          clearTimeout(longPressTimer);
          longPressTimer = null;
          return;
        }
        draggedElement = null;
      }
      
      function handleTouchMoveEditor(e) {
        e.preventDefault();
        if (!draggedElement) {
          const { x, y } = getMouseCoords(e);
          const dx = Math.abs(x - touchStartPos.x);
          const dy = Math.abs(y - touchStartPos.y);
          if (dx > LONG_PRESS_MOVE_THRESHOLD || dy > LONG_PRESS_MOVE_THRESHOLD) {
            isDragging = true;
            touchMoved = true;
            clearTimeout(longPressTimer);
            longPressTimer = null;
          }
        } else {
          const { x, y } = getMouseCoords(e);
          const dragX = x + draggedElement.offsetX;
          const dragY = y + draggedElement.offsetY;
          if (draggedElement.type === "gate") {
            const gate = gates[draggedElement.index];
            const { minY, maxY } = getVerticalLimits(draggedElement.index);
            let newY = dragY;
            newY = Math.max(newY, minY);
            newY = Math.min(newY, maxY);
            gate.x = dragX;
            gate.y = newY;
            const dir = gate.color === "red" ? 1 : -1;
            gate.line.x1 = gate.x;
            gate.line.y1 = gate.y;
            gate.line.x2 = gate.x + dir * 200;
            gate.line.y2 = gate.y;
          } else if (draggedElement.type === "tree") {
            const tree = trees[draggedElement.index];
            tree.x = dragX;
            tree.y = dragY;
          }
          drawTrack(currentTrack);
        }
      }
      
      function handleTouchEndEditor(e) {
        e.preventDefault();
        if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
        if (isDragging) {
          isDragging = false;
          checkEditorConstraints(draggedElement);
          draggedElement = null;
          drawTrack(currentTrack);
          return;
        }
        if (isLongPressActive) {
          isLongPressActive = false;
          return;
        }
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;
        if (tapLength > 0 && tapLength < 300) {
          handleDoubleConfirm();
        }
        lastTap = currentTime;
      }
      
      function addTree(x, y) {
        if (!editingMode) return;
        if (touchMoved) return;
        if (!isValidTreePosition(x, y, trees.length)) {
          showTemporaryMessage("Invalid position for new tree!", 1500);
          return;
        }
        trees.push({ x, y });
        drawTrack(currentTrack);
        showTemporaryMessage("New tree added!", 1500);
      }
      
      if (!document._eventsAttached) {
        canvas.addEventListener("mousedown", handleMouseDown);
        canvas.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
      
        canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
        canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
        canvas.addEventListener("touchend", handleTouchEnd, { passive: false });
        canvas.addEventListener("touchcancel", handleTouchEnd, { passive: false });
        // Listener per catturare "touchend" anche fuori dal canvas
        document.addEventListener("touchend", (e) => {
          if (!editingMode && drawing) {
            handleTouchEndGame(e);
          }
        }, { passive: false });
      
        let closeIntroOverlay = document.getElementById("closeIntroOverlay");
        if (closeIntroOverlay) {
          closeIntroOverlay.addEventListener("click", function() {
            window.location.href = "index.html";
          });
        }
        document._eventsAttached = true;
      }
      canvas.addEventListener("mousedown", function() {
  const ring = document.getElementById("start-ring");
  if (ring) ring.style.display = "none";
});
canvas.addEventListener("touchstart", function() {
  const ring = document.getElementById("start-ring");
  if (ring) ring.style.display = "none";
});
      function findNearestGate(x, y, maxDist) {
        let foundIndex = null;
        let bestDist = Infinity;
        for (let i = 0; i < gates.length; i++) {
          let dx = gates[i].x - x;
          let dy = gates[i].y - y;
          let dist = Math.hypot(dx, dy);
          if (dist < maxDist && dist < bestDist) {
            bestDist = dist;
            foundIndex = i;
          }
        }
        return foundIndex !== null ? { index: foundIndex } : null;
      }
      function findNearestTree(x, y, maxDist) {
        let foundIndex = null;
        let bestDist = Infinity;
        for (let i = 0; i < trees.length; i++) {
          let dx = trees[i].x - x;
          let dy = trees[i].y - y;
          let dist = Math.hypot(dx, dy);
          if (dist < maxDist && dist < bestDist) {
            bestDist = dist;
            foundIndex = i;
          }
        }
        return foundIndex !== null ? { index: foundIndex } : null;
      }
      
 function handleDoubleConfirm() {
  if (editingMode && !draggedElement) {
    editingMode = false;
    // Resetta la pista: questa funzione richiamer√† positionStartRing()
    resetTrack(currentTrack);
    callParticipant();
    showTemporaryMessage("Slope confirmed! Race starting...", 2000);
    const container = document.querySelector('.container');
    container.style.background = "url('sfondo.png') no-repeat center center";
    container.style.backgroundSize = "cover";
    // Assicuriamoci che l'anello venga posizionato subito
    positionStartRing();
  }
}
      
      function checkEditorConstraints(dragged) {
        if (dragged.type === "gate") {
          let g = gates[dragged.index];
          const { minY, maxY } = getVerticalLimits(dragged.index);
          if (g.y < minY || g.y > maxY || !isValidGatePosition(g.x, g.y, dragged.index)) {
            console.log("Posizione gate non valida. Revertendo...");
            g.x = dragged.oldX;
            g.y = dragged.oldY;
            const dir = g.color === "red" ? 1 : -1;
            g.line.x1 = g.x;
            g.line.y1 = g.y;
            g.line.x2 = g.x + dir * 200;
            g.line.y2 = g.y;
          } else {
            console.log("Posizione gate valida.");
          }
        } else if (dragged.type === "tree") {
          let t = trees[dragged.index];
          if (!isValidTreePosition(t.x, t.y, dragged.index)) {
            console.log("Posizione albero non valida. Revertendo...");
            t.x = dragged.oldX;
            t.y = dragged.oldY;
          } else {
            console.log("Posizione albero valida.");
          }
        }
      }
      function isValidGatePosition(x, y, idxGate) {
        const minEdge = 20;
        if (x < minEdge || x > canvas.width - minEdge) return false;
        if (y < 60 || y > canvas.height - 60) return false;
        const minGate = 35;
        for (let i = 0; i < gates.length; i++) {
          if (i === idxGate) continue;
          let dist = Math.hypot(x - gates[i].x, y - gates[i].y);
          if (dist < minGate) return false;
        }
        const minTree = 30;
        for (let tr of trees) {
          let dist = Math.hypot(x - tr.x, y - tr.y);
          if (dist < minTree) return false;
        }
        const minStart = 40;
        if (Math.hypot(x - startPoint.x, y - startPoint.y) < minStart) return false;
        if (isNearFinish(x, y, finishRect, 50)) return false;
        return true;
      }
      function isValidTreePosition(x, y, idxTree) {
        const margin = 15;
        if (x < margin || x > canvas.width - margin) return false;
        if (y < 60 || y > canvas.height - margin) return false;
        const minGate = 50;
        for (let g of gates) {
          let dist = Math.hypot(x - g.x, y - g.y);
          if (dist < minGate) return false;
        }
        const minTree = 30;
        for (let i = 0; i < trees.length; i++) {
          if (i === idxTree) continue;
          let dist = Math.hypot(x - trees[i].x, y - trees[i].y);
          if (dist < minTree) return false;
        }
        if (isNearFinish(x, y, finishRect, 50)) return false;
        const minStart = 40;
        if (Math.hypot(x - startPoint.x, y - startPoint.y) < minStart) return false;
        return true;
      }
      function getVerticalLimits(index) {
        let minY = 0;
        let maxY = canvas.height;
        if (index > 0) {
          minY = gates[index - 1].y + MIN_VERTICAL_GAP;
        }
        if (index < gates.length - 1) {
          maxY = gates[index + 1].y - MIN_VERTICAL_GAP;
        }
        return { minY, maxY };
      }

      /* ==============================================
         GESTIONE DELLE COLLISIONI E DEL FINISH
      ============================================== */
      function checkIntersections() {
        for (let i = 1; i < pointsPath.length; i++) {
          const p1 = pointsPath[i - 1],
                p2 = pointsPath[i];
          // Collisione con alberi in modalit√† hardMode
          if (hardMode) {
  for (const tree of trees) {
    const steps = Math.ceil(Math.hypot(p2.x - p1.x, p2.y - p1.y) / 5);
    // Calcola l'offset relativo in base all'altezza del canvas
    const treeCollisionOffset = (10 / 520) * canvas.height;
    const collisionThreshold = treeCollisionOffset; // soglia di collisione relativa
    for (let j = 0; j <= steps; j++) {
      const ix = p1.x + ((p2.x - p1.x) * j) / steps;
      const iy = p1.y + ((p2.y - p1.y) * j) / steps;
      const dist = Math.hypot(ix - tree.x, iy - (tree.y - treeCollisionOffset));
      if (dist < collisionThreshold) {
        // Gestisci la collisione con l'albero
        let currentPlayer = participants[currentIndex];
        if (!treeHits[currentPlayer]) {
          treeHits[currentPlayer] = 1;
        } else {
          treeHits[currentPlayer]++;
        }
        failAttempt("You hit a tree!");
        return;
      }
    }
  }
}

          // --- NUOVA LOGICA PER I GATE ---
          for (const gate of gates) {
            if (
              linesIntersect(
                p1.x, p1.y, p2.x, p2.y,
                gate.line.x1, gate.line.y1, gate.line.x2, gate.line.y2
              )
            ) {
              if (gate.number < expectedGate) {
                continue;
              }
              if (gate.number === expectedGate) {
                expectedGate++;
              } else {
                didFinishOrFailThisRun = true;
                failAttempt("You missed a gate!");
                return;
              }
            }
          }
          // Controllo per il finish
          if (
            p1.y < finishRect.y &&
            p2.y >= finishRect.y &&
            !isSegmentInFinishArea(p1, p2, finishRect)
          ) {
            failAttempt("Run interrupted!");
            return;
          }
          if (isSegmentInFinishArea(p1, p2, finishRect)) {
            if (expectedGate === gates.length + 1) {
              finishRun();
            } else {
              failAttempt("You missed a gate!");
            }
            return;
          }
        }
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        const det = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3);
        if (det === 0) return false;
        const lambda = ((y4 - y3) * (x4 - x1) + (x3 - x4) * (y4 - y1)) / det;
        const gamma = ((y1 - y2) * (x4 - x1) + (x2 - x1) * (y4 - y1)) / det;
        return lambda >= 0 && lambda <= 1 && gamma >= 0 && gamma <= 1;
      }
      function isSegmentInFinishArea(p1, p2, rect) {
        if (
          (p1.y < rect.y && p2.y < rect.y) ||
          (p1.y > rect.y + rect.height && p2.y > rect.y + rect.height)
        )
          return false;
        if (
          (p1.x < rect.x && p2.x < rect.x) ||
          (p1.x > rect.x + rect.width && p2.x > rect.x + rect.width)
        )
          return false;
        return true;
      }
      function isNearFinish(x, y, rect, minD) {
        return (
          x >= rect.x - minD &&
          x <= rect.x + rect.width + minD &&
          y >= rect.y - minD &&
          y <= rect.y + rect.height + minD
        );
      }

      /* ==============================================
         GESTIONE DEI TENTATIVI / FINE RUN
      ============================================== */
      function failAttempt(msg) {
        drawing = false;
        didFinishOrFailThisRun = true;
        if (pointsPath.length > 0) {
          lastCompleteRun = JSON.parse(JSON.stringify(pointsPath));
          window.lastFinalTime = null;
        }
       if (blindState === 1 || blindState === 2) {
  let penalty = (blindState === 1) ? 3 : 5;
  setMainLabel("You failed! Opponents get +" + penalty + " points!");
  for (let player in championScores) {
    if (player !== participants[currentIndex]) {
      championScores[player] += penalty;
    }
  }
  updatePointsLeaderboard();
} else {
  setMainLabel(msg);
}
        attemptCount++;
        setTimeout(() => nextParticipant(), 2000);
      }
function finishRun() {
  drawing = false;
  didFinishOrFailThisRun = true;
  const endTime = performance.now();
  const elapsedTime = endTime - startTime;
  const distPx = calculateDistance(pointsPath);
  const realLength = distPx * (window.conversionFactor || 1);
  let baseTime = calculateFinalTime(elapsedTime, realLength);
  let currentPlayer = participants[currentIndex];
  let extraPenalty = 0;
  if (treeHits[currentPlayer]) {
    extraPenalty = 0.02 * Math.pow(2, treeHits[currentPlayer] - 1);
  }
  let outPenaltyTotal = outPenaltyCount * 0.1;
  const finalTime = baseTime + extraPenalty + outPenaltyTotal;
  window.lastFinalTime = finalTime;
  lastCompleteRun = JSON.parse(JSON.stringify(pointsPath));
  lastSnowActive = showSnow;
  let penaltyText = outPenaltyTotal > 0 ? `<span style="color:red;"> (+${outPenaltyTotal.toFixed(2)})</span>` : "";
  setMainLabel(`‚è∞${formatTime(finalTime)}${penaltyText}`);

  // Aggiorna l'array bestTimes con il nuovo risultato
  let wasFirst = updateTimes(finalTime);
  if (wasFirst) {
    infoLine.classList.add("record");
    setTimeout(() => infoLine.classList.remove("record"), 2000);
  }

  // Ora controlla se il nuovo tempo rientra nei Top 5
  let newRunInTop5 = bestTimes.some(entry => entry.name === currentPlayer && entry.time === finalTime);

  attemptCount++;
  resetBlindMode();

  if (newRunInTop5) {
    // Salva i dati del tempo appena fatto per l'evidenziazione
    lastRunHighlight = { name: currentPlayer, time: finalTime };
    // Aggiorna la leaderboard e la classifica punti
    updateLeaderboard();
    updateProvisionalScores();
    // Apri automaticamente il popup dopo 0.5 secondi
    setTimeout(() => {
      chronoOverlay.classList.remove("hidden");
      autoPopupOpened = true; // Imposta il flag per indicare che il popup √® stato aperto in automatico
    }, 500);
  } else {
    // Altrimenti, prosegui normalmente passando al partecipante successivo dopo 2 secondi
    setTimeout(() => nextParticipant(), 2000);
  }
}



      function calculateDistance(arr) {
        let tot = 0;
        for (let i = 1; i < arr.length; i++) {
          let dx = arr[i].x - arr[i - 1].x;
          let dy = arr[i].y - arr[i - 1].y;
          tot += Math.hypot(dx, dy);
        }
        return tot;
      }
      function calculateFinalTime(ms, dist) {
        const s = ms / 1000;
        const penalty = PENALTY_WEIGHT * (dist / PATH_LENGTH_SCALING);
        return 60 + s + penalty;
      }
      function formatTime(sec) {
        const m = Math.floor(sec / 60);
        const r = (sec % 60).toFixed(3);
        return `${m}'${r.replace(".", '"')}'''`;
      }
      function updateTimes(t) {
        const nameValue = participants[currentIndex];
        const replayData = JSON.parse(JSON.stringify(pointsPath));
      
const newResult = {
  name: nameValue,
  time: t,
  replay: replayData,
  blind: blindState,  // Salva lo stato corrente: 0, 1 o 2
  correctTime: t !== undefined ? t : null
};
      
        bestTimes.push(newResult);
        bestTimes.sort((a, b) => a.time - b.time);
        if (bestTimes.length > 5) bestTimes.length = 5;
        const isBest = bestTimes[0].time === t;
        updateLeaderboard();
        return isBest;
      }
      
      chronoButton.addEventListener("click", () => {
  updateLeaderboard();      // Aggiorna la lista dei Top 5
  updateProvisionalScores(); // Calcola e mostra il punteggio cumulativo aggiornato
  chronoOverlay.classList.remove("hidden");
});
closeOverlay.addEventListener("click", () => {
  chronoOverlay.classList.add("hidden");
  if (autoPopupOpened) {
    nextParticipant();
    autoPopupOpened = false; // Resetta il flag
    lastRunHighlight = null; // Resetta anche l'evidenziazione
  }
});
function updateLeaderboard() {
  const lb = document.getElementById("leaderboardList");
  lb.innerHTML = "";
  bestTimes.forEach((entry, i) => {
    const li = document.createElement("li");
    let blindMark = "";
    if (entry.blind === 1) {
      blindMark = "(+3)";
    } else if (entry.blind === 2) {
      blindMark = "(+5)";
    }
    if (i === 0) {
      li.innerHTML = `${entry.name} - ${formatTime(entry.time)}${blindMark} 
        <img src="replay.png" alt="Replay" style="width:1.2em; height:1.2em; cursor:pointer; transform: translateY(0.2em);">`;
      li.style.fontWeight = "bold";
      li.style.cursor = "pointer";
      li.title = "Click to watch the best replay";
      li.addEventListener("click", () => {
        chronoOverlay.classList.add("hidden");
        replayTrajectory(entry.replay, entry.correctTime, entry.blind);
      });
    } else {
      li.textContent = `${entry.name} - ${formatTime(entry.time)}${blindMark}`;
    }
    
    // Se questo entry corrisponde al tempo appena fatto, aggiungi la classe per farlo lampeggiare
    if (
      lastRunHighlight &&
      entry.name === lastRunHighlight.name &&
      entry.time === lastRunHighlight.time
    ) {
      li.classList.add("record");
    }
    
    lb.appendChild(li);
  });
}
    function updatePointsLeaderboard() {
  const tableBody = document.getElementById("pointsLeaderboardBody");
  tableBody.innerHTML = "";
  const sortedPlayers = Object.keys(championScores).sort(
    (a, b) => championScores[b] - championScores[a]
  );
  sortedPlayers.forEach((player, i) => {
    const row = document.createElement("tr");
    const nameCell = document.createElement("td");
    const pointsCell = document.createElement("td");
    nameCell.textContent = player;
    pointsCell.textContent = championScores[player];
    if (i === 0) {
      row.style.fontWeight = "bold"; // Il giocatore in testa
    }
    row.appendChild(nameCell);
    row.appendChild(pointsCell);
    tableBody.appendChild(row);
  });
}
      // Questa funzione calcola i punteggi cumulativi provvisori.
// championScores contiene i punteggi finalizzati delle gare precedenti.
// bestTimes contiene le run della gara in corso.
function updateProvisionalScores() {
  // Inizializza il punteggio provvisorio con i punteggi gi√† finalizzati
  let provisionalScores = {};
  participants.forEach(p => {
    provisionalScores[p] = championScores[p] || 0;
  });

  // Ordina i tempi della gara corrente (bestTimes) in ordine crescente (migliore tempo al primo posto)
  let sorted = [...bestTimes].sort((a, b) => a.time - b.time);
  
  // Per i primi 5 tempi, assegna i punti corrispondenti (es. [9,7,5,3,1])
  // aggiungendo il bonus se la run √® in Blind Mode (blind===1) o Blind2 Mode (blind===2)
  for (let i = 0; i < sorted.length && i < 5; i++) {
    let pointsAwarded = CHAMPION_POINTS[i]; // CHAMPION_POINTS √® l'array con [9, 7, 5, 3, 1]
    if (sorted[i].blind === 1) {
      pointsAwarded += 3;
    } else if (sorted[i].blind === 2) {
      pointsAwarded += 5;
    }
    provisionalScores[sorted[i].name] += pointsAwarded;
  }
  
  // Aggiorna la visualizzazione della classifica punti con i punteggi provvisori
  updatePointsLeaderboardWithScores(provisionalScores);
}

// Questa funzione aggiorna l'elemento della classifica punti (Points Standings)
// usando un oggetto scores passato come parametro.
function updatePointsLeaderboardWithScores(scores) {
  const tableBody = document.getElementById("pointsLeaderboardBody");
  tableBody.innerHTML = "";
  // Ordina i giocatori per punteggio (decrescente)
  const sortedPlayers = Object.keys(scores).sort((a, b) => scores[b] - scores[a]);
  sortedPlayers.forEach(player => {
    const row = document.createElement("tr");
    const nameCell = document.createElement("td");
    const pointsCell = document.createElement("td");
    nameCell.textContent = player;
    pointsCell.textContent = scores[player];
    row.appendChild(nameCell);
    row.appendChild(pointsCell);
    tableBody.appendChild(row);
  });
}

      /* ==============================================
         REPLAY della Traiettoria
      ============================================== */
      let lastCompleteRun = null;
      replayButton.addEventListener("click", () => {
        if (lastCompleteRun && lastCompleteRun.length >= 2) {
          replayTrajectory(lastCompleteRun);
        } else {
          showTemporaryMessage("No run to replay!", 2000);
        }
      });
      function replayTrajectory(customPoints, correctTime, wasBlind) {
  // Nascondi subito l'anello per evitare che venga visualizzato durante il replay
  const ring = document.getElementById("start-ring");
  if (ring) {
    ring.style.display = "none";
  }
  
  const savedMainLabel = mainLabel;
  if (!customPoints || customPoints.length < 2) {
    showTemporaryMessage("No run to replay!", 1000);
    return;
  }
  const container = document.querySelector('.container');
  const originalBackground = container.style.background;
  container.style.background = "url('sfondoreplay.png') no-repeat center center";
  container.style.backgroundSize = "cover";
  
  // Mostra il tempo sul display
  const chronoIcon = '‚è∞';
  if (correctTime !== undefined && correctTime !== null) {
    setMainLabel(`${chronoIcon} ${formatTime(correctTime)}`);
  } else if (window.lastFinalTime !== undefined && window.lastFinalTime !== null) {
    setMainLabel(`${chronoIcon} ${formatTime(window.lastFinalTime)}`);
  } else {
    setMainLabel(`${chronoIcon} No time to show`);
  }
  
  // Configura (e, se necessario, attiva) la neve in base allo stato precedente
  const preReplaySnowState = showSnow;
  if (lastSnowActive) {
    showSnow = true;
    snowCanvasElem.classList.remove("hidden");
    snowCanvasElem.width = canvas.width;
    snowCanvasElem.height = canvas.height;
    initSnow();
    updateSnow();
  } else {
    snowCanvasElem.classList.add("hidden");
  }
  
  clearCanvas();
  drawStartPoint();
  drawFinishArea();
  drawGates(gates);
  drawTrees(trees);
  
  let i = 0;
  function step() {
    if (i >= customPoints.length - 1) {
      setTimeout(() => {
        clearCanvas();
        if (currentTrack) drawTrack(currentTrack);
        // Ripristina lo sfondo originale
        container.style.background = originalBackground;
        // Ripristina il label originale
        setMainLabel(savedMainLabel);
        // Ora, uscendo dal replay, riposiziona l'anello (lo vedrai nel gioco)
        positionStartRing();
      }, 500);
      return;
    }
    ctx.beginPath();
    ctx.moveTo(customPoints[i].x, customPoints[i].y);
    ctx.lineTo(customPoints[i + 1].x, customPoints[i + 1].y);
    ctx.strokeStyle = wasBlind ? "#ff4d4d" : "#a4b8eb";
    ctx.lineWidth = (2 / 520) * canvas.height;
    ctx.stroke();
    const dt = customPoints[i + 1].t - customPoints[i].t;
    i++;
    setTimeout(step, dt);
  }
  setTimeout(step, 0);
}


      /* ==============================================
         BLIND MODE
      ============================================== */
      const blindToggleButton = document.getElementById("blindToggle");
      // blindState: 0 = View Mode, 1 = Blind Mode (¬±3 pts), 2 = Blind2 Mode (¬±5 pts)
      let blindState = 0;

const blindIcon = document.getElementById("blindIcon");

blindToggleButton.addEventListener("click", () => {
  if (blindState === 0) {
    blindState = 1;
    blindIcon.src = "hide.png";      // Inserisci qui l'icona per Blind Mode (¬±3 pts)
    blindIcon.alt = "Blind Mode (+/-3 pts)";
  } else if (blindState === 1) {
    blindState = 2;
    blindIcon.src = "hide2.png";     // Inserisci qui l'icona per Blind2 Mode (¬±5 pts)
    blindIcon.alt = "Blind2 Mode (+/-5 pts)";
  } else if (blindState === 2) {
    blindState = 0;
    blindIcon.src = "view.png";       // Icona per View Mode
    blindIcon.alt = "View Mode";
  }
});
    function resetBlindMode() {
  blindState = 0;
  blindIcon.src = "view.png";
  blindIcon.alt = "View Mode";
}

      /* ==============================================
         GESTIONE DELLA GARA: Tentativi, Cambio partecipante, ecc.
      ============================================== */
      function nextParticipant() {
        resetBlindMode();
        if (attemptCount >= 3) {
          attemptCount = 0;
          currentIndex++;
          if (currentIndex >= participants.length) {
            if (runNumber === 1) {
              runNumber = 2;
              currentIndex = 0;
              showPopup(
                `
                <div style="font-size: 20px; text-align: center;">
                  Starting the<br>
                  <b>2nd manche</b><br>
                  of <b>race #${raceNumber}!</b>
                </div>
                `,
                () => {
                  resetTrack(currentTrack);
                  callParticipant();
                }
              );
            } else {
              endRace();
            }
          } else {
            const nxt = participants[currentIndex];
            showPopup(
              `
              <div style="font-size:20px; text-align:center;">
                Now it's <b>${nxt}</b>'s turn!
              </div>
              `,
              () => {
                resetTrack(currentTrack);
                callParticipant();
              }
            );
          }
        } else {
          resetTrack(currentTrack);
          callParticipant();
        }
      }
      function callParticipant() {
        let att = attemptCount + 1;
        let currentPlayer = participants[currentIndex];
        let penaltyDisplay = "";
        if (treeHits[currentPlayer]) {
          let penaltyVal = 0.02 * Math.pow(2, treeHits[currentPlayer] - 1);
          penaltyDisplay = ` (+${penaltyVal.toFixed(2)}s)`;
        }
        let msg = 
          `<span style="color: black;">${currentPlayer}</span> ` +
          `<span style="color: rgba(0,0,0,0.3);">R#${raceNumber}</span> ` +
          `<span style="color: rgba(0,0,0,0.6);">M#${runNumber}</span> ` +
          `<span style="color: black;">Run#${att}</span> ` +
          `<span style="color: red;">${penaltyDisplay}</span>`;
        setMainLabel(msg);
        let newWeatherState = chooseWeatherState(weatherState);
        showSnow = applyWeatherState(newWeatherState);
        if (showSnow) {
          snowCanvasElem.classList.remove("hidden");
          snowCanvasElem.width = canvas.width;
          snowCanvasElem.height = canvas.height;
          initSnow();
          updateSnow();
        } else {
          snowCanvasElem.classList.add("hidden");
        }
      }
  function resetTrack(track) {
  drawing = false;
  pointsPath = [];
  intersectedGates.clear();
  if (editingMode) {
    setMainLabel("Double-tap here to start!");
  } else {
    setMainLabel(`‚è∞1'00"000'''`);
  }
  resetBlindMode();
  clearCanvas();
  if (track) drawTrack(track);
  // Mostra l'anello all'inizio della run
  positionStartRing();
}
function endRace() {
  const sorted = [...bestTimes].sort((a, b) => a.time - b.time);
  for (let i = 0; i < 5; i++) {
    if (i < sorted.length) {
      const entry = sorted[i];
      championScores[entry.name] += CHAMPION_POINTS[i];
      // Se il run √® stato fatto in Blind o Blind2 mode, assegna il bonus
      if (entry.blind === 1 || entry.blind === 2) {
        let bonus = (entry.blind === 1) ? 3 : 5;
        championScores[entry.name] += bonus;
      }
    }
  }
  showRaceResults();
}
      function showRaceResults() {
  let sortedTimes = [...bestTimes].sort((a, b) => a.time - b.time);
  let html =
    `<h2>Final Times (Top 5)</h2>
    <div class="champ-table">
      <table>
        <tr><th>Player</th><th>Time</th></tr>`;
  sortedTimes.forEach((e) => {
    let blindMark = "";
    if (e.blind === 1) {
      blindMark = "(+3)";
    } else if (e.blind === 2) {
      blindMark = "(+5)";
    }
    html += `<tr><td>${e.name}</td><td>${formatTime(e.time)}${blindMark}</td></tr>`;
  });
  html += `</table></div>`;
        const sortedPlayers = Object.keys(championScores).sort(
          (a, b) => championScores[b] - championScores[a]
        );
        html +=
          `<h2>Race Standings #${raceNumber}</h2>
          <div class="champ-table">
            <table>
              <tr><th>Player</th><th>Total Points</th></tr>`;
        sortedPlayers.forEach((name) => {
          html += `<tr><td>${name}</td><td>${championScores[name]}</td></tr>`;
        });
        html += `</table></div>`;
        let btnLabel = "Next Race!";
        let action = () => {
          champOverlay.classList.add("hidden");
          raceNumber++;
          participants = sortedPlayers.slice().reverse();
          setupRace();
        };
        if (raceNumber >= 3) {
          btnLabel = "Final Standings!";
          action = showFinalResults;
        }
        html += `<button class="nav-button">${btnLabel}</button>`;
        champContent.innerHTML = html;
        champContent.querySelector(".nav-button").addEventListener("click", action);
        champOverlay.classList.remove("hidden");
      }
    function showFinalResults() {
        let sortedPlayers = Object.keys(championScores).sort(
          (a, b) => championScores[b] - championScores[a]
        );
        const winner = sortedPlayers[0];
        let html =
          `<h2>Final Standings</h2>
          <div class="champ-table">
            <table>
              <tr><th>Player</th><th>Punti</th></tr>`;
        sortedPlayers.forEach((n) => {
          html += `<tr><td>${n}</td><td>${championScores[n]}</td></tr>`;
        });
        html += `</table></div>`;
        html += `<h3>Wins ${winner}!!!</h3>`;
        html +=
          `<div class="end-buttons">
            <button id="btnReplayChamp">Play Again!</button>
            <button id="btnSolo">Play Solo</button>
          </div>`;
        champContent.innerHTML = html;
        champContent.querySelector("#btnReplayChamp").addEventListener("click", () => {
          champOverlay.classList.add("hidden");
          slidesOverlay.classList.remove("hidden");
          currentSlideIndex = 0;
          renderSlide();
        });
        champContent.querySelector("#btnSolo").addEventListener("click", () => {
          window.location.href = "index.html";
        });
        champOverlay.classList.remove("hidden");
      }


      function setupRace() {
        lastCompleteRun = null;
        setMainLabel(`‚è∞1'00"000'''`);
        let newWeatherState;
        if (!weatherState) {
          newWeatherState = chooseWeatherState(null);
        } else {
          newWeatherState = chooseWeatherState(weatherState);
        }
        applyWeatherState(newWeatherState);
        showSnow = false;
        snowCanvasElem.classList.add("hidden");
        currentTrack = createTrackForRace(raceNumber);
        resizeCanvas();
        drawTrack(currentTrack);
        bestTimes = [];
        updateLeaderboard();
        currentIndex = 0;
        attemptCount = 0;
        runNumber = 1;
        editingMode = true;
        const container = document.querySelector('.container');
        container.style.background = "url('sfondoedit.png') no-repeat center center";
        container.style.backgroundSize = "cover";
        resetTrack(currentTrack);
      }

      /* ==============================================
         POPUP GENERICO
      ============================================== */
      function showPopup(message, onOk) {
        champContent.innerHTML = `
          <h2>Attention!</h2>
          <p class="slide-content">${message}</p>
          <div class="popup-button-container">
            <button class="nav-button" id="popupOkButton">OK</button>
          </div>`;
        champOverlay.classList.remove("hidden");
        document.getElementById("popupOkButton").addEventListener("click", () => {
          champOverlay.classList.add("hidden");
          if (onOk) onOk();
        });
      }
      function showConfirmPopup(message, onConfirm, onCancel) {
        champContent.innerHTML = `
          <button id="closePopup" style="position: absolute; top: 10px; left: 10px; background-color: #8fa2f7; font-size: 0.875em; padding: 0.5em 1em; color: white; border: none; border-radius: 5px; cursor: pointer;">X</button>
          <h2>Attention!</h2>
          <p class="slide-content">${message}</p>
          <div class="popup-button-container" style="margin-top: 15px;">
            <button class="nav-button" id="popupConfirmButton" style="color: #007bff; font-weight: bold;">OK</button>
          </div>`;
        champOverlay.classList.remove("hidden");
        document.getElementById("popupConfirmButton").addEventListener("click", () => {
          champOverlay.classList.add("hidden");
          if (onConfirm) onConfirm();
        });
        document.getElementById("closePopup").addEventListener("click", () => {
          champOverlay.classList.add("hidden");
          if (onCancel) onCancel();
        });
      }

      /* ==============================================
         SLIDES INTRO & GESTIONE DEI PLAYER
      ============================================== */
      slidesIntro = [
        {
          title: "World Cup Mode",
          content: `
            <p class="overlay-text">Enter the players!</p>
            <div id="playersInputContainer"></div>
            <button id="addPlayerBtn" style="margin-right:8px;">Add Player</button>
            <button id="removePlayerBtn">Remove Player</button>
          `
        },
        {
          title: "Race Format",
          content: `
            <p class="overlay-text">There will be <b>3 distinct races</b> <i>(Giant, Special, SuperG)</i>.<br>
            <span style="display:block; border-top:1px solid red; margin:8px 0;"></span>
            <p class="overlay-text">‚ùÑ Each race has <b>2 Manches</b>, and in each manche every participant has <b>3 consecutive attempts</b> <i>(Runs)</i>.<span style="display:block; border-top:1px solid red; margin:8px 0;"></span>
            <p class="overlay-text">‚ùÑ At the end of each race, the <b>top 5 best times</b> are awarded points:<br><i><b>(9, 7, 5, 3, 1).</b></i></p>
          `
        },
        {
          title: "Editing the Track",
          content: `
            <p class="overlay-text">Before each race, you can <b>edit the track</b> by simply dragging the gates and trees with your finger, as long as you respect the constraints set by the editor.<br>
            <span style="display:block; border-top:1px solid red; margin:8px 0;"></span>
            <p class="overlay-text">‚ùÑ <b>Press and hold</b> anywhere on the track for <b>one second</b> to create a <b>new tree</b>, then move it freely.<br>
            <span style="display:block; border-top:1px solid red; margin:8px 0;"></span>
            <p class="overlay-text">‚ùÑ <b>Double-tap</b> the infoline to <b>confirm</b> the track and <b>start the race!</b><br>
            <span style="display:block; border-top:1px solid red; margin:8px 0;"></span>
            <p class="overlay-text"><i><b>Remember:</b> no matter how you design the track, red gates must be passed on the right, and blue gates on the left.</i></p>
          `
        },
        {
          title: "Brave Mode<br>& Penalties",
          content: `
            <p class="overlay-text">‚ùÑ If you hit a tree, you receive a <b>0.02-second penalty</b> on your next run, and the penalty doubles for each additional tree you hit!<br>
            <span style="display:block; border-top:1px solid red; margin:8px 0;"></span>
            <p class="overlay-text">‚ùÑ If you hit the side barriers, you might receive a <b>0.10-second penalty!</b><br>
            <span style="display:block; border-top:1px solid red; margin:8px 0;"></span>
            <p class="overlay-text">
              <img src="view.png" class="tutorial-icon" alt="view" style="margin-bottom:-6px;">
              By clicking the <b>Brave Mode</b> button, you choose to take a risk!
If, by the end of the race, your time is among the Top 5, you earn a <b>3 or 5 point bonus</b>.<br>
<b>But if you fail to make the Top 5</b>, your opponents receive those 3 or 5 points instead!</p>
          `
        },
        {
          title: "Final Victory",
          content: `
            <p class="overlay-text">At the end of the 3rd race, whoever has the most points wins the championship!
            <span style="display:block; border-top:1px solid red; margin:8px 0;"></span></p>
            <p class="overlay-text"><b>Enjoy the slope!</b></p>
          `
        }
      ];
      let currentTutorialIndex = 0;
      let draftParticipants = [];
      function renderSlide() {
        slidesOverlay.classList.remove("hidden");
        const slide = slidesIntro[currentTutorialIndex];
        slidesContent.innerHTML = `
          <button id="closeIntroOverlay" class="close-button">X</button>
          <div style="margin-top:5px;">
            <h2 class="slide-title">${slide.title}</h2>
            <p class="slide-content">${slide.content}</p>
            <div class="tutorial-dots"></div>
            <div class="slides-nav">
              <button class="nav-button" id="btnPrev">‚Üê</button>
              <button class="nav-button" id="btnStartNow">Start!</button>
              <button class="nav-button" id="btnNext">‚Üí</button>
            </div>
          </div>`;
        const dotsC = slidesContent.querySelector(".tutorial-dots");
        slidesIntro.forEach((s, i) => {
          const d = document.createElement("div");
          d.className = "dot" + (i === currentTutorialIndex ? " active" : "");
          d.addEventListener("click", () => {
            syncDraftParticipants();
            currentTutorialIndex = i;
            renderSlide();
          });
          dotsC.appendChild(d);
        });
        const btnPrev = slidesContent.querySelector("#btnPrev");
        btnPrev.disabled = currentTutorialIndex === 0;
        btnPrev.addEventListener("click", () => {
          if (currentTutorialIndex > 0) {
            syncDraftParticipants();
            currentTutorialIndex--;
            renderSlide();
          }
        });
        slidesContent.querySelector("#btnStartNow").addEventListener("click", () => {
          syncDraftParticipants();
          if (!checkDraftNames()) return;
          acceptDraftParticipants();
          startChampionship();
        });
        const btnNext = slidesContent.querySelector("#btnNext");
        btnNext.disabled = currentTutorialIndex === slidesIntro.length - 1;
        btnNext.addEventListener("click", () => {
          if (currentTutorialIndex < slidesIntro.length - 1) {
            syncDraftParticipants();
            currentTutorialIndex++;
            renderSlide();
          }
        });
        if (currentTutorialIndex === 0) {
          renderPlayersInput();
        }
        let closeIntroOverlay = document.getElementById("closeIntroOverlay");
        if (closeIntroOverlay) {
          closeIntroOverlay.addEventListener("click", function() {
            window.location.href = "index.html";
          });
        }
      }
      function renderPlayersInput() {
        const cont = slidesContent.querySelector("#playersInputContainer");
        if (!cont) return;
        cont.innerHTML = "";
        if (draftParticipants.length < 2) {
          draftParticipants = ["", ""];
        }
        draftParticipants.forEach((n) => {
          addPlayerField(cont, n);
        });
        slidesContent.querySelector("#addPlayerBtn").addEventListener("click", () => {
          syncDraftParticipants();
          if (draftParticipants.length < 6) {
            draftParticipants.push("");
            renderSlide();
          } else {
            alert("Max 6 participants!");
          }
        });
        slidesContent.querySelector("#removePlayerBtn").addEventListener("click", () => {
          syncDraftParticipants();
          if (draftParticipants.length > 2) {
            draftParticipants.pop();
            renderSlide();
          }
        });
      }
      function addPlayerField(container, def = "") {
        const d = document.createElement("div");
        d.innerHTML = `
          <input type="text" class="player-name-input"
            placeholder="Player name"
            value="${def}"
            maxlength="6"
          />`;
        container.appendChild(d);
      }
      function syncDraftParticipants() {
        const inputs = slidesContent.querySelectorAll(".player-name-input");
        if (inputs.length === 0) return;
        draftParticipants = [];
        inputs.forEach((inp) => {
          const val = inp.value.trim();
          if (val) draftParticipants.push(val);
        });
      }
      function checkDraftNames() {
        if (draftParticipants.length < 2) {
          alert("At least 2 participants!");
          return false;
        }
        if (draftParticipants.length > 6) {
          alert("Max 6 participants!");
          return false;
        }
        const duplicates = draftParticipants.some(
          (nm, idx) => draftParticipants.indexOf(nm) !== idx
        );
        if (duplicates) {
          alert("Names must be unique!");
          return false;
        }
        return true;
      }
      function acceptDraftParticipants() {
        participants = [...draftParticipants];
      }
      function startChampionship() {
        championScores = {};
        participants.forEach((p) => {
          championScores[p] = 0;
          treeHits[p] = 0;
        });
        slidesOverlay.classList.add("hidden");
        raceNumber = 1;
        runNumber = 1;
        setupRace();
      }

      /* ==============================================
         GESTIONE DEL QUIT
      ============================================== */
      document.getElementById("quit").addEventListener("click", () => {
        showConfirmPopup("Are you sure you want to quit?", 
          () => {
            window.location.href = "index.html";
          },
          () => {
            console.log("Quit canceled");
          }
        );
      });
      
      document.addEventListener("DOMContentLoaded", () => {
        resizeCanvas();
        renderSlide();
        resetBlindMode();
      
        const infoLineEl = document.getElementById("infoLine");
        function handleTouchEndDoubleTap(e) {
          if (isDragging || isLongPressActive) return;
          const currentTime = new Date().getTime();
          const tapLength = currentTime - lastTap;
          if (tapLength > 0 && tapLength < 300) {}
          lastTap = currentTime;
        }
      
        infoLineEl.addEventListener("touchend", handleTouchEndDoubleTap, false);
        infoLineEl.addEventListener("dblclick", handleDoubleConfirm, false);
      });
      document.addEventListener("DOMContentLoaded", () => {
        animate();
      });

      /* ==============================================
         FINE SCRIPT
      ============================================== */
    </script>
    <div class="bottom-space"></div>
  </body>
</html>
