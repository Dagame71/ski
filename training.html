<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Collegamento al Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- Icona per dispositivi Apple -->
    <link rel="apple-touch-icon" href="icon192.png">
    
    <!-- Disabilita la barra URL in Safari quando aperto dalla Home -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- Nome visualizzato nella Home Screen -->
    <meta name="apple-mobile-web-app-title" content="Ski-Zag!">
    
    <!-- Colore della barra di stato -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <!-- Forza l'orientamento portrait su iOS -->
    <meta name="apple-mobile-web-app-orientation" content="portrait">
    
    <!-- Registra il Service Worker -->
    <script>
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("service-worker.js")
          .then(() => console.log("Service Worker registrato!"))
          .catch(error => console.log("Errore nel Service Worker:", error));
      }
    </script>

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ski Solo – Responsive Version</title>

    <style>
      /* Stili di base */
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        font-family: "Helvetica Neue", Arial, sans-serif;
        background: #c4d3fc;
        margin-top: 0px;
      }

      body {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .container {
        position: relative;
        width: 90%; /* Larghezza in percentuale, per essere responsive */
        max-width: 90vw; /* Limita la larghezza massima al 90% della viewport */
        aspect-ratio: 300 / 520; /* Mantiene il rapporto di aspetto */
        background: #e1dffc url("sfondo.png") no-repeat center center;
        background-size: cover;
        border: 0px solid #ffffff;
        border-radius: 10px;
        margin-top: 10px;
        box-sizing: border-box;
        overflow: hidden;
      }

      canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        cursor: crosshair;
      }

      /* Canvas per la neve */
      #snowCanvas {
        position: fixed; /* per coprire tutto lo schermo */
        top: 0;
        left: 0;
        width: 100vw;   /* copre l'intera larghezza finestra */
        height: 100vh;  /* copre l'intera altezza finestra */
        pointer-events: none; /* la neve non intercetta clic/touch */
        z-index: 5; /* layer intermedio */
      }

      /* Bottoni */
      button {
        position: relative; /* assicura che il z-index abbia effetto */
        z-index: 10;        /* valore superiore a 5 */
        border: none !important; /* Rimuove qualsiasi bordo */
        outline: none; /* Rimuove il contorno del focus */
        border-radius: 8px; /* Angoli arrotondati */
        background: rgba(255, 255, 255, 0.3); /* Sfondo bianco semitrasparente */
        box-shadow: 
          inset 1px 1px 2px rgba(255, 255, 255, 0.8), /* Effetto embossed (rilievo) */
          inset -1px -1px 2px #434d74,                /* Effetto ombra interna */
          1px 1px 2px #434d74;                        /* Ombra esterna per effetto 3D */
        padding: 6px 8px; /* Spazio interno per un aspetto più bilanciato */
        transition: all 0.2s ease-in-out; /* Effetto di transizione */
      }

      button:hover {
        background: rgba(255, 255, 255, 0.5); /* Più trasparenza al passaggio del mouse */
        box-shadow:
          inset 1px 1px 3px rgba(255, 255, 255, 0.8),
          inset -1px -1px 3px #434d74,
          1px 1px 3px #434d74;
      }

      .button-disabled {
        background-color: transparent;
        border: 0px solid #aaa; /* Bordo scuro per simulare effetto premuto */
        color: transparent; /* Colore del testo trasparente */
        cursor: not-allowed; /* Cambia il cursore */
        opacity: 0.4; /* Rende il pulsante meno evidente */
      }

      .button-disabled:hover {
        opacity: 0.7;
      }

      .play-button {
        display: block;
        margin: 20px auto 0; /* Sposta il pulsante verso il basso e lo centra */
        background-color: #8fa2f7; /* Colore del pulsante */
        font-size: 16px;
        padding: 10px 20px;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        text-align: center;
      }

      .play-button:hover {
        background-color: #bdc9fb; /* Colore hover */
      }

      /* Posizionamento bottoni di controllo (vuoti) */
      #sameTrack {
      }
      #challengeButton {
      }
      #replayButton {
      }
      #quit {
      }
      #homeBtn {
      }
      #chronoButton {
      }
      #viewBtn {
      }
      #saveResultBtn {
      }

      /* Contenitore delle info */
      .info-container {
        width: 90vw;
        max-width: 500px;
        margin: 2px auto;
        padding: 1px;
        margin-top: -3px; /* Valore negativo per alzare leggermente il blocco */
        border: 0px solid #9cc1e2;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.2); /* Sfondo leggero trasparente */
        display: flex;
        box-shadow:
          inset 1px 1px 3px rgba(0, 0, 0, 0.2),
          inset -1px -1px 3px #9cc1e2;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        z-index: 9999; /* come da impostazione originale */
        user-select: none;            /* Standard */
        -webkit-user-select: none;    /* Safari e vecchi */
        -moz-user-select: none;       /* Firefox */
        -ms-user-select: none;        /* IE/Edge */
        -webkit-touch-callout: none;  /* Previene i menu contestuali su iOS */
      }

      /* Unica riga di testo per i messaggi (cronometro, avvisi, etc.) */
      #infoLine {
        margin: 5px 0;
        font-weight: bold;
        font-size: 1.2em; /* Dimensione relativa */
        min-height: 20px;
        text-align: center;
        color: black;
      }

      .centered-button {
        display: flex;
        justify-content: center;
        width: 100%;
      }

      /* Overlay e animazioni */
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 9999;
        display: flex;
        justify-content: center;
        align-items: center;
        animation: fadeIn 0.3s ease;
      }

      @keyframes blink {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0;
        }
      }

      .record {
        animation: blink 0.5s ease-in-out 3;
      }

      .hidden {
        display: none;
      }

      .overlay-content {
        background-image: url("backpopup.png");
        background-repeat: no-repeat;
        background-position: center;
        background-size: cover;
        background-color: #fff;
        border-radius: 12px;
        padding: 20px;
        width: 80%; /* Larghezza responsive */
        max-width: 280px;
        box-sizing: border-box;
        position: relative;
        text-align: center;
        color: #333;
        box-shadow:
          inset 4px 4px 2px rgba(175, 219, 245, 0.8),
          inset -4px -4px 2px rgba(255, 255, 255, 0.8);
      }

      .overlay-text {
        font-size: 14px; /* Ridotta per migliorare la lettura su schermi piccoli */
        line-height: 1.3;
      }

      /* Bottoni per chiudere gli overlay */
      #closeChronoOverlay,
      #closeViewOverlay,
      #closeSaveResultOverlay {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: #8fa2f7;
        font-size: 14px;
        padding: 5px 10px;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }

      #closeChronoOverlay:hover,
      #closeViewOverlay:hover,
      #closeSaveResultOverlay:hover {
        background-color: #bdc9fb;
      }

      /* Input identico a .player-name-input */
      #trackNameInput,
      #resultNameInput {
        background: #ffffff;
        border: 1px solid #bdc9fb;
        border-radius: 16px;
        padding: 10px;
        width: 80%;
        margin-bottom: 8px;
        box-shadow:
          inset 3px 3px 4px rgba(0, 0, 0, 0.2),
          inset -3px -3px 4px rgba(255, 255, 255, 0.7);
        outline: none;
        font-size: 1em;
        transition: all 0.2s ease-in-out;
      }

      /* Effetto focus identico */
      #trackNameInput:focus,
      #resultNameInput:focus {
        background: #ffffff;
        box-shadow:
          inset 2px 2px 4px rgba(0, 0, 0, 0.3),
          inset -2px -2px 4px rgba(255, 255, 255, 0.8);
      }

      /* Campo di input del salvataggio Challenge */
      #challengeSaveName {
        background: #ffffff;
        border: 1px solid #bdc9fb;
        border-radius: 16px;
        padding: 10px;
        width: 80%;
        margin-bottom: 8px;
        box-shadow:
          inset 3px 3px 4px rgba(0, 0, 0, 0.2),
          inset -3px -3px 4px rgba(255, 255, 255, 0.7);
        outline: none;
        font-size: 1em;
        transition: all 0.2s ease-in-out;
      }

      /* Effetto focus */
      #challengeSaveName:focus {
        background: #ffffff;
        box-shadow:
          inset 2px 2px 4px rgba(0, 0, 0, 0.3),
          inset -2px -2px 4px rgba(255, 255, 255, 0.8);
      }

      /* Leaderboard */
      .leaderboard-container {
        display: block;
        width: 100%;
        margin-top: 10px;
      }

      .leaderboard {
        width: 95%;
        margin: 0 auto;
      }

      .leaderboard h2 {
        text-align: center;
        margin: 10px 0;
      }

      ol {
        border: 1px solid #999bf2;
        border-radius: 5px;
        list-style: decimal inside;
        min-height: 100px;
        padding: 10px;
        margin: 0;
      }

      li {
        padding: 5px 0;
      }

      /* Stili per il tutorial (slide) */
      .intro-overlay {
      }

      .slide-content {
        margin-bottom: 20px;
        line-height: 1.4;
      }

      .slide-title {
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 22px;
      }

      .slides-nav {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 15px;
      }

      .tutorial-icon {
        width: 20px;
        height: 20px;
        vertical-align: middle;
        position: relative;
        top: -2px; /* Regola l'altezza abbassando leggermente l'icona */
        margin-right: 5px;
      }

      .medal-title-icon {
        width: 22px;
        height: 22px;
        vertical-align: middle;
        margin-left: 8px;
      }

      .slides-nav .nav-button {
        background: #007bff;
        color: #fff;
        border: none;
        border-radius: 8px;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
      }

      @media (hover: hover) {
        .slides-nav .nav-button:hover {
          background: #bdc9fb; /* Azzurro più chiaro in hover */
        }
      }

      .tutorial-dots {
        display: flex;
        justify-content: center;
        gap: 8px;
        margin: 10px 0;
      }

      .dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #ffffff;
        cursor: pointer;
        transition: background 0.3s;
      }

      .dot.active {
        background: #007bff;
      }

      /* Pulsanti delete per le piste salvate */
      .deleteBtn {
        background-color: #999bf2;
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 12px;
        padding: 2px 4px;
        margin-left: 10px;
        cursor: pointer;
      }

      .deleteBtn:hover {
        background-color: #cbcdf9;
      }

      @media (min-width: 768px) {
        .container {
          max-width: 500px !important;
        }
      }

      /* =======================
         IMMAGINE LOGO IN BASSO
         ======================= */
      .bottom-space {
        width: 100%;
        height: 80px;
        background: url("logo.png") no-repeat center bottom;
        background-size: contain;
        flex-shrink: 0;
      }

      /* Se l'altezza dello schermo è sotto i 700px, nascondi la .bottom-space */
      @media (max-height: 700px) {
        .bottom-space {
          display: none;
        }
      }

      #saveTrackBtn, 
      #saveResultConfirmBtn, 
      #popupConfirmButton {
        color: #007bff;  /* Colore blu */
        font-weight: bold;
        background: transparent;
        border: none;
        cursor: pointer;
      }

      #saveTrackBtn:hover, 
      #saveResultConfirmBtn:hover, 
      #popupConfirmButton:hover {
        text-decoration: underline; /* Sottolinea al passaggio del mouse */
      }

      /* Contenitore per i bottoni in basso */
      .bottom-buttons {
        position: absolute;       /* Posiziona il contenitore rispetto al div .container */
        bottom: 1.15%;            /* Fissa a 1.15% dal fondo del container */
        left: 0;
        right: 0;
        display: flex;           
        justify-content: space-around;  
        gap: 5px; /* Spazio fisso minore fra i bottoni */
        align-items: center;
        z-index: 10; 
      }

      /* Sovrascrive la regola duplicata, distribuendo lo spazio tra i gruppi */
      .bottom-buttons {
        position: absolute;
        bottom: 1.15%;
        left: 0;
        right: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        z-index: 10;
        padding: 0 5%;
      }

      /* Gruppo Sinistro */
      .left-bottom-group {
        display: flex;
        justify-content: space-around;
        align-items: center;
        width: 45%;
        margin-left: -5%; 
      }

      /* Gruppo Destro */
      .right-bottom-group {
        display: flex;
        justify-content: space-around;
        align-items: center;
        width: 45%;
        margin-right: -5%;
      }

      .bottom-buttons button {
        position: static;
        width: 30%;
        max-width: 35px;
        aspect-ratio: 1 / 1;
        padding: 4px 6px;
      }

      .top-buttons {
        pointer-events: none;
        position: absolute; 
        top: 1%; 
        left: 0;
        right: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 5%;
        z-index: 10;
      }

      .top-buttons button {
        pointer-events: auto;
        position: static;  
        width: 30%;
        max-width: 35px;
        aspect-ratio: 1 / 1;
        padding: 4px 6px;
      }

      #homeBtn {
      }
      #chronoButton {
      }

      .saved-item-text {
        cursor: pointer;
        color: #007bff;  /* Testo blu */
        text-decoration: underline;
        font-size: 16px;
        font-family: "Helvetica Neue", Arial, sans-serif;
      }

      .overlay-content p {
        margin: 4px 0; 
        line-height: 1.2;
      }
    </style>
  </head>

  <body>
    <!-- Canvas NEVE a pagina intera -->
    <canvas id="snowCanvas" class="hidden"></canvas>

    <!-- CONTENITORE DI GIOCO -->
    <div class="container" id="gameContainer">
      <canvas id="canvas"></canvas>

      <!-- Contenitore per i bottoni in alto -->
      <div class="top-buttons">
        <button id="homeBtn" title="Home">
          <img src="home.png" alt="Home" style="width:19px; height:19px;" />
        </button>
        <button id="chronoButton" title="Top 5">
          <img src="stopwatch.png" alt="Top 5" style="width:19px; height:19px;" />
        </button>
      </div>

      <!-- Raggruppamento dei bottoni in basso -->
      <div class="bottom-buttons">
        <!-- Gruppo Sinistro: da sinistra verso il centro -->
        <div class="left-bottom-group">
          <button id="replayButton" title="Replay">
            <img src="replay.png" alt="Replay" style="width:19px; height:19px;" />
          </button>
          <button id="saveResultBtn" title="Save Result">
            <img src="cup.png" alt="Save Result" style="width:19px; height:19px;" />
          </button>
          <button id="viewBtn" title="Save Track">
            <img src="save.png" alt="Save Track" style="width:19px; height:19px;" />
          </button>
        </div>

        <!-- Gruppo Destro: dal centro verso destra -->
        <div class="right-bottom-group">
          <button id="challengeButton" title="Challenge Mode">
            <img src="medal.png" alt="Challenge" style="width:19px; height:19px;" />
          </button>
          <button id="sameTrack" title="Toggle Snow">
            <img src="snowflake.png" alt="Toggle Snow" style="width:19px; height:19px;" />
          </button>
          <button id="quit" title="New Run">
            <img src="new.png" alt="New Run" style="width:19px; height:19px;" />
          </button>
        </div>
      </div>
    </div>

    <!-- UNICA RIGA PER TUTTI I MESSAGGI (tempo + avvisi) -->
    <div class="info-container">
      <p id="infoLine">
        <img
          src="stopwatch.png"
          alt="Stopwatch"
          style="width:18px; height:18px; vertical-align:middle; margin-right:4px;"
        />
        0'00"000'''
      </p>
    </div>

    <!-- OVERLAY TOP 5 -->
    <div id="chronoOverlay" class="overlay hidden">
      <div class="overlay-content">
        <button id="closeChronoOverlay">X</button>
        <div class="leaderboard-container">
          <div class="leaderboard">
            <h2>Top 5</h2>
            <ol id="leaderboardList"></ol>
          </div>
        </div>
      </div>
    </div>

    <!-- OVERLAY View: per salvare e CARICARE le piste -->
    <div id="viewOverlay" class="overlay hidden">
      <div class="overlay-content">
        <button id="closeViewOverlay">X</button>
        <h2>Saved Tracks</h2>
        <div id="savedTracksList"></div>
        <hr />
        <h3>Save current track</h3>
        <input type="text" id="trackNameInput" placeholder="Enter track name" maxlength="15" />
        <button id="saveTrackBtn">Save Track</button>
      </div>
    </div>

    <!-- OVERLAY Save Result: per salvare il tempo realizzato -->
    <div id="saveResultOverlay" class="overlay hidden">
      <div class="overlay-content">
        <button id="closeSaveResultOverlay">X</button>
        <h2>Save Your Result</h2>
        <input type="text" id="resultNameInput" placeholder="Enter your name" maxlength="6" />
        <button id="saveResultConfirmBtn">Save Result</button>
      </div>
    </div>

    <!-- OVERLAY Challenge Intro -->
    <div id="challengeIntroOverlay" class="overlay hidden">
      <div class="overlay-content">
        <!-- Pulsante di chiusura aggiunto in alto a sinistra, identico agli altri -->
        <button id="closeChallengeIntroButton" style="
          position: absolute;
          top: 10px;
          left: 10px;
          background-color: #8fa2f7;
          font-size: 14px;
          padding: 5px 10px;
          color: white;
          border: none;
          border-radius: 5px;
          cursor: pointer;
        ">X</button>

        <h2>Welcome to the Challenge Mode!</h2>
        <p class="overlay-text">
          <strong>Beat the best time, level up, and achieve the highest score!</strong>
        </p>
        <hr style="border:none; border-top:1px solid red; margin:8px 0;">
        <p class="overlay-text">
          ❄ You have <b>3 attempts</b> to beat the best time; the more you lower it, the more points you earn!
        </p>
        <hr style="border:none; border-top:1px solid red; margin:8px 0;">
        <p class="overlay-text">
          ❄ <strong>Beat the level:</strong><br>
          <strong>1st try</strong> → points x3<br>
          <strong>2nd</strong> → points x2<br>
          <strong>3rd</strong> → points x1
        </p>
        <!-- Il pulsante "Play!" rimane invariato -->
        <button id="closeChallengeIntroOverlay" class="play-button">Play!</button>
      </div>
    </div>

    <!-- OVERLAY FINALE CHALLENGE: per fallimento o fine partita -->
    <div id="challengeEndOverlay" class="overlay hidden">
      <div class="overlay-content" id="challengeEndContent" style="text-align: center;">
        <!-- Contenuto gestito via JS -->
      </div>
    </div>

    <!-- OVERLAY TUTORIAL -->
    <div id="tutorialOverlay" class="overlay" style="z-index: 10001;">
      <div class="overlay-content intro-overlay">
        <div id="tutorialContent"></div>
        <div class="tutorial-dots" id="tutorialDots"></div>
        <div class="slides-nav">
          <button class="nav-button" id="tutorialPrev">←</button>
          <button class="nav-button" id="tutorialStart">Start!</button>
          <button class="nav-button" id="tutorialNext">→</button>
        </div>
      </div>
    </div>

    <script>
      /* ==============================================
         VARIABILI GLOBALI E IMPOSTAZIONI
         ============================================== */

      const PATH_LENGTH_SCALING = 500;
      const PENALTY_WEIGHT = 0.5;
      const BORDER_THRESHOLD = 5;
      const hardMode = true; // Abilita collisione con alberi

      // Variabile per il controllo della neve: di default la neve è abilitata
      let snowLocked = false;

      // Variabili per la gestione della neve (logica simile a un "campionato")
      let snowIntensity = 0;
      let showSnow = false;
      let weatherState = null;

      /* Funzione che sceglie casualmente lo stato meteo (che influenza la neve) */
      function chooseWeatherState(prevState) {
        const r = Math.random() * 100;
        if (r < 60) return "nn";  // "No Neve"
        else if (r < 80) return "pn";  // "Poca Neve"
        else if (r < 95) return "mn";  // "Molta Neve"
        else return "nf";             // "Neve Forte"
      }

      /* Applica lo stato meteo e imposta i parametri di intensità neve */
      function applyWeatherState(state) {
        if (state === "nn") {
          snowIntensity = 0;
        } else if (state === "pn") {
          snowIntensity = 300;
        } else if (state === "mn") {
          snowIntensity = 1000;
        } else if (state === "nf") {
          snowIntensity = 3250;
        }
        showSnow = snowIntensity > 0;
        return showSnow;
      }

      let canvas = document.getElementById("canvas");
      let ctx = canvas.getContext("2d");
      let snowCanvas = document.getElementById("snowCanvas");
      let snowCtx = snowCanvas.getContext("2d");

      // Singolo elemento per mostrare il tempo e i messaggi
      const infoLine = document.getElementById("infoLine");

      /* Variabili per testo (messaggi temporanei e testo principale) */
      let mainLabel = "⏰0'00\"000'''";

      /* Aggiorna l'etichetta principale */
      function setMainLabel(text) {
        // Se siamo in Challenge Mode e il testo inizia con "⏰", non forzare il testo normale
        if (isChallengeMode && text.startsWith("⏰")) {
          return;
        }

        // Sostituisce tutte le occorrenze di "⏰" con l'icona di un cronometro
        let replacedText = text.replaceAll(
          "⏰",
          '<img src="stopwatch.png" alt="Stopwatch" style="width:18px; height:18px; position: relative; top:-2px; vertical-align:middle; margin-right:4px;">'
        );

        mainLabel = replacedText;
        infoLine.innerHTML = replacedText;
      }

      /* Mostra un messaggio temporaneo e poi ritorna al testo principale */
      function showTemporaryMessage(msg, duration = 2000) {
        let old = mainLabel;
        infoLine.innerHTML = msg;
        infoLine.classList.remove("record");
        setTimeout(() => {
          infoLine.innerHTML = old;
        }, duration);
      }

      /* Mostra un messaggio temporaneo formattato in HTML */
      function showTemporaryMessageHtml(html, duration = 2000) {
        let old = mainLabel;
        infoLine.innerHTML = html;
        infoLine.classList.remove("record");
        setTimeout(() => {
          infoLine.innerHTML = old;
        }, duration);
      }

      // Bottoni
      let sameTrackButton = document.getElementById("sameTrack");
      let replayButton = document.getElementById("replayButton");
      let quitButton = document.getElementById("quit");
      let homeBtn = document.getElementById("homeBtn");
      let chronoButton = document.getElementById("chronoButton");
      let viewBtn = document.getElementById("viewBtn");
      let saveResultBtn = document.getElementById("saveResultBtn");

      // Overlay
      let chronoOverlay = document.getElementById("chronoOverlay");
      let closeChronoOverlay = document.getElementById("closeChronoOverlay");
      let viewOverlay = document.getElementById("viewOverlay");
      let closeViewOverlay = document.getElementById("closeViewOverlay");
      let saveResultOverlay = document.getElementById("saveResultOverlay");
      let closeSaveResultOverlay = document.getElementById("closeSaveResultOverlay");
      let tutorialOverlay = document.getElementById("tutorialOverlay");
      let tutorialContent = document.getElementById("tutorialContent");
      let tutorialDots = document.getElementById("tutorialDots");
      let tutorialPrev = document.getElementById("tutorialPrev");
      let tutorialNext = document.getElementById("tutorialNext");
      let tutorialStart = document.getElementById("tutorialStart");

      // Variabili di gioco
      let currentTrack = null;  // Contiene gates e trees
      let bestTimes = [];       // Array dei migliori tempi (Top 5)
      let savedTracks = {};     // Piste salvate (LocalStorage)
      let currentTrackName = ""; // Nome della pista corrente (se salvata)
      window.lastFinalTime = 0; // Tempo finale dell'ultimo run completato

      let gates = [];
      let trees = [];
      let pointsPath = [];
      let drawing = false;
      let startTime = 0;
      let lastCompleteRun = null;
      let outPenaltyCount = 0;
      let isOut = false;
      let falseStartCount = 0;
      let intersectedGates = new Set();
      let didFinishOrFail = false; 
      let expectedGate = 1;

      let startPoint = { x: 150, y: 30 }; // Punto di partenza
      let finishRect = { x: 130, y: 490, width: 40, height: 10 }; // Area di arrivo
      let globalWind = Math.random() * 1 - 0.5; // Vento casuale

      /* Variabili per Challenge Mode */
      let isChallengeMode = false;
      let challengeBestTime = 0;
      let challengeAttempts = 0;
      let isGeneratingChallenge = false;
      let challengePoints = 0;
      let leaderboard = [];

      /* Gestione dei "titoli" sbloccati in base al livello */
      const baseSpeed = 3.5; // Velocità iniziale di default
      let speed = baseSpeed;
      const speedDecrement = 0.05; 
      let currentLevel = 1; 
      let currentChallengeSaveName = ""; 
      let currentPlayerName = localStorage.getItem("currentPlayerName") || "Anonymous";

      /* Gruppi di titoli e logica calcolo (funzioni getTitleForLevel, getTitleImageForLevel) */
      const challengeTitles = [
        "Snowflake Apprentice",
        "Frosty Daredevil",
        "Blizzard Tamer",
        "Polar Maestro",
        "Avalanche Overlord"
      ];
      let currentTitleUnlocked = "";

      function getTitleForLevel(level) {
        if (level < 3) {
          return "";
        }

        const baseTitles = [
          "Snowflake Apprentice",
          "Frosty Daredevil",
          "Blizzard Tamer",
          "Polar Maestro",
          "Avalanche Overlord"
        ];

        const subTitles = ["Bronze", "Silver", "Gold"];
        let adjusted = level - 2;
        let baseIndex = Math.floor((adjusted - 1) / 9);

        if (baseIndex >= baseTitles.length) {
          return baseTitles[baseTitles.length - 1] + " Gold";
        }

        if (baseIndex < 0) {
          return "";
        }

        let baseTitle = baseTitles[baseIndex];
        let subIndex = Math.floor(((adjusted - 1) % 9) / 3);

        if (subIndex >= subTitles.length) {
          subIndex = subTitles.length - 1;
        }

        let subTitle = subTitles[subIndex];
        return baseTitle + " " + subTitle;
      }

      function getTitleImageForLevel(level) {
        if (level < 3) {
          return "";
        }

        const titleImages = [
          [
            "snowflake_apprentice_bronze.png",
            "snowflake_apprentice_silver.png",
            "snowflake_apprentice_gold.png"
          ],
          [
            "frosty_daredevil_bronze.png",
            "frosty_daredevil_silver.png",
            "frosty_daredevil_gold.png"
          ],
          [
            "blizzard_tamer_bronze.png",
            "blizzard_tamer_silver.png",
            "blizzard_tamer_gold.png"
          ],
          [
            "polar_maestro_bronze.png",
            "polar_maestro_silver.png",
            "polar_maestro_gold.png"
          ],
          [
            "avalanche_overlord_bronze.png",
            "avalanche_overlord_silver.png",
            "avalanche_overlord_gold.png"
          ]
        ];

        let adjusted = level - 2;
        let baseIndex = Math.floor((adjusted - 1) / 9);

        if (baseIndex >= titleImages.length) {
          return titleImages[titleImages.length - 1][2];
        }

        if (baseIndex < 0) {
          return "";
        }

        let subIndex = Math.floor(((adjusted - 1) % 9) / 3);
        return titleImages[baseIndex][subIndex];
      }

      /* Slides Tutorial */
      let tutorialSlides = [
        {
          title: "Welcome to Ski-Zag!",
          content: `<p class="overlay-text">
        <b><i>Start at the hut and ski to the finish!</i></b><span style="display:block; border-top:1px solid red; margin:8px 0;"></span>
        ❄ Draw your path with your finger, pass through the gates, avoid the trees, cross the finish line and achieve <b>the best time!</b><br><span style="display:block; border-top:1px solid red; margin:8px 0;"></span>
        ❄ <b>Red gates</b> must be passed on the <b>right</b>, and <b>blue gates</b> on the <b>left</b>.<br>
        </p>`
        },
        {
          title: `Challenge Mode<img src="medal.png" class="medal-title-icon" alt="Medal">`,
          content: `<p class="overlay-text">
        <i><b>Beat the best time, level up, and achieve the highest score!</b></i><br>
<span style="display:block; border-top:1px solid red; margin:8px 0;"></span>
        ❄ You have <b>3 attempts</b> to beat the best time; the more you lower it, the more points you earn!<br><span style="display:block; border-top:1px solid red; margin:8px 0;"></span>
        ❄ <strong>Beat the level:</strong><br>
        <strong>1st try</strong> → points x3<br>
        <strong>2nd</strong> → points x2<br> 
        <strong>3rd</strong> → points x1
        </p>`
        },
        {
          title: "Buttons",
          content: `<div class="overlay-text controls-slide">
          <img src="replay.png" class="tutorial-icon" alt="Replay"> Replay<hr style="border:none; border-top:1px solid red; margin:8px 0;">
          <img src="cup.png" class="tutorial-icon" alt="Save Result"> Save your result<hr style="border:none; border-top:1px solid red; margin:8px 0;">
          <img src="save.png" class="tutorial-icon" alt="View / Save Track"> Save/load track<hr style="border:none; border-top:1px solid red; margin:8px 0;">
          <img src="medal.png" class="tutorial-icon" alt="Medal">Challenge Mode In/Out<hr style="border:none; border-top:1px solid red; margin:8px 0;">
          <img src="snowflake.png" class="tutorial-icon" alt="Toggle Snow"> Snow On/Off<hr style="border:none; border-top:1px solid red; margin:8px 0;">
          <img src="new.png" class="tutorial-icon" alt="New Track"> New Track<hr style="border:none; border-top:1px solid red; margin:8px 0;">
          <img src="stopwatch.png" class="tutorial-icon" alt="Top 5">Top 5 <i>(view best times)</i><hr style="border:none; border-top:1px solid red; margin:8px 0;">
          <img src="home.png" class="tutorial-icon" alt="homeBtn">Quit/Home
        </div>`
        },
        {
          title: "Good Luck!",
          content: `<p class="overlay-text">Have fun with Ski-Zag!<br><b>Enjoy the slope!</b></p>`
        }
      ];

      let currentTutorialIndex = 0;

      /* Funzione per gestire il ridimensionamento dinamico del canvas */
      const container = document.getElementById("gameContainer");
      function resizeCanvas() {
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        snowCanvas.width = container.clientWidth;
        snowCanvas.height = container.clientHeight;

        startPoint = { x: canvas.width / 2, y: (30 / 520) * canvas.height };
        finishRect = {
          x: canvas.width / 2 - 20,
          y: canvas.height - 50,
          width: 40,
          height: 10
        };

        drawTrack(currentTrack);
      }

      /* Pulisce il canvas di gioco */
      function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      /* Disegna il punto di partenza (casa) */
      function drawStartPoint() {
        const iconWidth = (16 / 300) * canvas.width;
        const iconHeight = (16 / 520) * canvas.height;
        ctx.drawImage(
          startIcon,
          startPoint.x - iconWidth / 2,
          startPoint.y - iconHeight / 2,
          iconWidth,
          iconHeight
        );
      }

      /* Disegna l'area di arrivo (bandiera a scacchi) */
      function drawFinishArea() {
        const { x, y, width, height } = finishRect;
        const sq = width / 8;
        let rowCount = Math.floor(height / (width / 8));
        for (let row = 0; row < rowCount; row++) {
          for (let col = 0; col < 8; col++) {
            ctx.fillStyle = (row + col) % 2 === 0 ? "black" : "#F0F0F0";
            ctx.fillRect(x + col * sq, y + row * sq, sq, sq);
          }
        }
      }

      /* Caricamento icone per i gate (rosso e blu) */
      const gateIcons = {
        red: new Image(),
        blue: new Image()
      };
      gateIcons.red.src = "red_gate.svg";
      gateIcons.blue.src = "blue_gate.svg";

      /* Icona di partenza */
      const startIcon = new Image();
      startIcon.src = "start.svg";

      /* Precaricamento dell'immagine dell'albero */
      const treeImg = new Image();
      treeImg.src = "tree.svg";
      treeImg.onload = () => {
        console.log("Immagine dell'albero caricata con successo.");
        drawTrack(currentTrack);
      };
      treeImg.onerror = () => {
        console.error("Errore nel caricamento di tree.svg");
      };

      /* Funzione che genera i gate */
      function generateGates(count) {
        let startWithRed = Math.random() < 0.5;
        let isRed = startWithRed;
        let arr = [];
        for (let i = 0; i < count; i++) {
          let dir = isRed ? 1 : -1;
          let x = isRed 
            ? Math.random() * (canvas.width / 2 - 35) + canvas.width / 2 
            : Math.random() * (canvas.width / 2 - 35) + 35;
          let y = (80 / 520) * canvas.height +
                  i * ((canvas.height - (120 / 520) * canvas.height) / count);
          let color = isRed ? "red" : "blue";
          arr.push({
            x: x,
            y: y,
            color: color,
            number: i + 1, // Numerazione del gate
            line: {
              x1: x,
              y1: y,
              x2: x + dir * ((200 / 300) * canvas.width),
              y2: y
            }
          });
          isRed = !isRed;
        }
        return arr;
      }

      /* Funzione che genera alberi evitando vicinanza eccessiva */
      function generateTrees(gArr) {
        let treeCount = Math.floor(Math.random() * 3) + 6;
        let arr = [];
        const margin = (15 / 520) * canvas.height,
              minGate = (50 / 300) * canvas.width,
              minTree = (30 / 520) * canvas.height,
              minFinish = (50 / 300) * canvas.width,
              minStart = (40 / 520) * canvas.height;
        while (arr.length < treeCount) {
          let tx = margin + Math.random() * (canvas.width - 2 * margin);
          let ty = (60 / 520) * canvas.height +
                   Math.random() * ((canvas.height - 40) - (60 / 520) * canvas.height);
          let closeGate = gArr.some((g) => Math.hypot(tx - g.x, ty - g.y) < minGate);
          let closeTrees = arr.some((t) => Math.hypot(tx - t.x, ty - t.y) < minTree);
          let closeFinish = isNearFinish(tx, ty, finishRect, minFinish);
          let closeStart = Math.hypot(tx - startPoint.x, ty - startPoint.y) < minStart;

          if (!closeGate && !closeTrees && !closeFinish && !closeStart) {
            arr.push({ x: tx, y: ty });
          }
        }
        return arr;
      }

      /* Crea una pista generando gates e alberi */
      function createTrack() {
        let g = generateGates(8);
        let t = generateTrees(g);
        return { gates: g, trees: t };
      }

      /* Disegna i gate sul canvas */
      function drawGates(gArr) {
        gArr.forEach((g) => {
          let icon = g.color === "red" ? gateIcons.red : gateIcons.blue;
          let iconWidth = (16 / 300) * canvas.width;
          let iconHeight = (16 / 520) * canvas.height;
          ctx.drawImage(icon, g.x - iconWidth / 2, g.y - iconHeight / 2, iconWidth, iconHeight);
        });
      }

      /* Disegna gli alberi sul canvas */
      function drawTrees(tArr) {
        if (!treeImg.complete) {
          console.warn("Immagine dell'albero non ancora caricata.");
          return;
        }
        tArr.forEach((t) => {
          const treeWidth = (12 / 300) * canvas.width;
          const treeHeight = (20 / 520) * canvas.height;
          ctx.drawImage(treeImg, t.x - treeWidth / 2, t.y - treeHeight, treeWidth, treeHeight);
        });
      }

      /* Disegna l'intera pista (start, arrivo, gate, alberi) */
      function drawTrack(track) {
        if (!track) return;
        clearCanvas();
        gates = track.gates;
        trees = track.trees;
        intersectedGates.clear();
        drawStartPoint();
        drawFinishArea();
        drawGates(gates);
        drawTrees(trees);
      }

      /* Gestione Neve */
      let snowflakes = [];

      /* Inizializza i fiocchi di neve */
      function initSnow() {
        snowflakes = [];
        for (let i = 0; i < snowIntensity; i++) {
          snowflakes.push({
            x: Math.random() * snowCanvas.width,
            y: Math.random() * snowCanvas.height,
            radius: Math.random() * 3 + 1,
            speedY: Math.random() * 0.5 + 0.5,
            speedX: Math.random() * 0.5 - 0.25
          });
        }
      }

      /* Aggiorna (anima) la neve */
      function updateSnow() {
        if (!showSnow) return;
        snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
        snowflakes.forEach((flake) => {
          flake.x += flake.speedX + globalWind;
          flake.y += flake.speedY;
          if (flake.y > snowCanvas.height) {
            flake.y = 0;
            flake.x = Math.random() * snowCanvas.width;
          }
          if (flake.x > snowCanvas.width) flake.x = 0;
          if (flake.x < 0) flake.x = snowCanvas.width;

          snowCtx.beginPath();
          snowCtx.arc(flake.x, flake.y, flake.radius, 0, Math.PI * 2);
          snowCtx.fillStyle = "white";
          snowCtx.fill();
        });
        requestAnimationFrame(updateSnow);
      }

      /* Eventi mouse / touch */
      if (!canvas._eventsAttached) {
        canvas.addEventListener("mousedown", handleMouseDown);
        canvas.addEventListener("mousemove", handleMouseMove);
        canvas.addEventListener("mouseup", handleMouseUp);
        canvas.addEventListener("touchstart", handleTouchStart);
        canvas.addEventListener("touchmove", handleTouchMove);
        canvas.addEventListener("touchend", handleTouchEnd);
        canvas._eventsAttached = true;
      }

      /* Restituisce le coordinate del mouse/touch corrette in base al canvas */
      function getMouseCoords(e) {
        let rect = canvas.getBoundingClientRect();
        let cx = e.touches ? e.touches[0].clientX : e.clientX;
        let cy = e.touches ? e.touches[0].clientY : e.clientY;
        return {
          x: ((cx - rect.left) / rect.width) * canvas.width,
          y: ((cy - rect.top) / rect.height) * canvas.height
        };
      }

      /* Controlla se l'utente sta iniziando dal punto di partenza (casa) */
      function isNearStartPoint(x, y) {
        return Math.hypot(x - startPoint.x, y - startPoint.y) <= (20 / 520) * canvas.height;
      }

      /* Gestione eventi mouse */
      function handleMouseDown(e) {
        let { x, y } = getMouseCoords(e);
        if (!isNearStartPoint(x, y)) {
          falseStartCount++;
          if (falseStartCount === 1) {
            showTemporaryMessageHtml(
              '<span style="color:red;">False start!</span> <span style="color:black;">2nd attempt!</span>',
              1500
            );
          } else if (falseStartCount === 2) {
            showTemporaryMessageHtml(
              '<span style="color:red;">False start!</span> <span style="color:black;">Last attempt!</span>',
              1500
            );
          } else if (falseStartCount >= 3) {
            setMainLabel("Run failed due to consecutive false starts!");
            failRun("Run failed due to false starts.");
            falseStartCount = 0;
          }
          setTimeout(() => {
            if (isChallengeMode && challengeBestTime > 0) {
              setMainLabel(`Beat this time: ${formatTime(challengeBestTime)}`);
            }
          }, 2000);
          return;
        }

        // Al momento del run, il prossimo gate atteso è il 1
        expectedGate = 1;

        falseStartCount = 0;
        outPenaltyCount = 0;
        isOut = false;
        drawing = true;
        pointsPath = [];
        startTime = performance.now();
        didFinishOrFail = false;

        setMainLabel("");
        ctx.beginPath();
        pointsPath.push({ x, y, t: 0 });
        ctx.moveTo(x, y);
      }

      function handleMouseMove(e) {
        if (!drawing) return;
        let { x, y } = getMouseCoords(e);
        let p1 = pointsPath[pointsPath.length - 1];
        let p2 = { x, y };
        if (p1 && checkInterpolationForBorder(p1, p2)) {
          if (!isOut) {
            outPenaltyCount++;
            isOut = true;
          }
        } else {
          isOut = false;
        }
        let now = performance.now() - startTime;
        pointsPath.push({ x, y, t: now });
        ctx.lineTo(x, y);
        ctx.strokeStyle = "#a4b8eb";
        ctx.lineWidth = (2 / 520) * canvas.height;
        ctx.stroke();
        checkIntersections();
      }

      function handleMouseUp(e) {
        if (!drawing) return;
        drawing = false;
        if (!didFinishOrFail) {
          failRun("Run interrupted!");
        }
      }

      /* Gestione eventi touch */
      function handleTouchStart(e) {
        e.preventDefault();
        let { x, y } = getMouseCoords(e);
        if (!isNearStartPoint(x, y)) {
          setMainLabel("You must start from the house icon!");
          setTimeout(() => {
            if (isChallengeMode && challengeBestTime > 0) {
              setMainLabel(`Beat this time: ${formatTime(challengeBestTime)}`);
            }
          }, 2000);
          return;
        }

        expectedGate = 1;
        falseStartCount = 0;
        outPenaltyCount = 0;
        isOut = false;
        drawing = true;
        pointsPath = [];
        startTime = performance.now();
        didFinishOrFail = false;

        setMainLabel("");
        ctx.beginPath();
        pointsPath.push({ x, y, t: 0 });
        ctx.moveTo(x, y);
      }

      function handleTouchMove(e) {
        e.preventDefault();
        if (!drawing) return;
        let { x, y } = getMouseCoords(e);
        let p1 = pointsPath[pointsPath.length - 1];
        let p2 = { x, y };
        if (p1 && checkInterpolationForBorder(p1, p2)) {
          if (!isOut) {
            outPenaltyCount++;
            isOut = true;
          }
        } else {
          isOut = false;
        }
        let now = performance.now() - startTime;
        pointsPath.push({ x, y, t: now });
        ctx.lineTo(x, y);
        ctx.strokeStyle = "#a4b8eb";
        ctx.lineWidth = (2 / 520) * canvas.height;
        ctx.stroke();
        checkIntersections();
      }

      function handleTouchEnd(e) {
        e.preventDefault();
        if (!drawing) return;
        drawing = false;
        if (!didFinishOrFail) {
          failRun("Run interrupted!");
        }
      }

      /* Verifica se l'utente esce dai bordi */
      function checkInterpolationForBorder(p1, p2) {
        const stepLength = 2;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const distance = Math.hypot(dx, dy);
        const steps = Math.ceil(distance / stepLength);
        for (let i = 1; i <= steps; i++) {
          const t = i / steps;
          const ix = p1.x + t * dx;
          const iy = p1.y + t * dy;
          if (ix < BORDER_THRESHOLD || ix > canvas.width - BORDER_THRESHOLD) {
            return true;
          }
        }
        return false;
      }

      /* Funzione che controlla le collisioni con alberi, gates e finish */
      function checkIntersections() {
        for (let i = 1; i < pointsPath.length; i++) {
          let p1 = pointsPath[i - 1],
              p2 = pointsPath[i];

          // Controllo collisione alberi (hardMode)
          if (hardMode) {
            let steps = Math.ceil(Math.hypot(p2.x - p1.x, p2.y - p1.y) / 5);
            for (let j = 0; j <= steps; j++) {
              let ix = p1.x + ((p2.x - p1.x) * j) / steps;
              let iy = p1.y + ((p2.y - p1.y) * j) / steps;
              for (const tree of trees) {
                let dist = Math.hypot(ix - tree.x, iy - (tree.y - (10 / 520) * canvas.height));
                if (dist < (10 / 520) * canvas.height) {
                  didFinishOrFail = true;
                  failRun("You hit a tree!");
                  return;
                }
              }
            }
          }

          // Nuova logica per i gates
          for (const gate of gates) {
            if (
              linesIntersect(
                p1.x, p1.y, p2.x, p2.y,
                gate.line.x1, gate.line.y1, gate.line.x2, gate.line.y2
              )
            ) {
              if (gate.number < expectedGate) {
                continue;
              }
              if (gate.number === expectedGate) {
                expectedGate++;
              } else {
                didFinishOrFail = true;
                failRun("You missed a gate!");
                return;
              }
            }
          }

          // Se il segmento scende oltre la y del traguardo senza passare effettivamente nell'area di finish
          if (
            p1.y < finishRect.y &&
            p2.y >= finishRect.y &&
            !isSegmentInFinishArea(p1, p2, finishRect)
          ) {
            didFinishOrFail = true;
            failRun("Run interrupted!");
            return;
          }

          // Finish
          if (isSegmentInFinishArea(p1, p2, finishRect)) {
            didFinishOrFail = true;
            if (expectedGate === gates.length + 1) {
              finishRun();
            } else {
              failRun("You missed a gate!");
            }
            return;
          }
        }
      }

      /* Controlla se due segmenti di linea si intersecano */
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        const det = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3);
        if (det === 0) return false;
        const lambda = ((y4 - y3) * (x4 - x1) + (x3 - x4) * (y4 - y1)) / det;
        const gamma = ((y1 - y2) * (x4 - x1) + (x2 - x1) * (y4 - y1)) / det;
        return lambda >= 0 && lambda <= 1 && gamma >= 0 && gamma <= 1;
      }

      /* Controlla se un segmento "entra" nel rettangolo di arrivo */
      function isSegmentInFinishArea(p1, p2, rect) {
        if (
          (p1.y < rect.y && p2.y < rect.y) ||
          (p1.y > rect.y + rect.height && p2.y > rect.y + rect.height)
        )
          return false;
        if (
          (p1.x < rect.x && p2.x < rect.x) ||
          (p1.x > rect.x + rect.width && p2.x > rect.x + rect.width)
        )
          return false;
        return true;
      }

      /* Controlla se un punto (x,y) è vicino all'area di finish */
      function isNearFinish(x, y, rect, minD) {
        return (
          x >= rect.x - minD &&
          x <= rect.x + rect.width + minD &&
          y >= rect.y - minD &&
          y <= rect.y + rect.height + minD
        );
      }

      /* Funzioni di fine run / fallimento run */
      function finishRun() {
        drawing = false;
        didFinishOrFail = true;

        let endTime = performance.now();
        let elapsedTime = endTime - startTime;

        let distPx = calculateDistance(pointsPath);
        let baseTime = calculateFinalTime(elapsedTime, distPx);
        let outPenaltyTotal = outPenaltyCount * 0.1;
        let finalTime = baseTime + outPenaltyTotal;

        lastCompleteRun = JSON.parse(JSON.stringify(pointsPath));
        window.lastFinalTime = finalTime;

        if (isChallengeMode) {
          setMainLabel(`Your time: ${formatTime(finalTime)}`);
          setTimeout(() => {
            if (finalTime <= challengeBestTime) {
              let differenceInCents = Math.max(0, Math.floor((challengeBestTime - finalTime) * 100));
              let multiplier = challengeAttempts;
              let pointsEarned = differenceInCents * multiplier;

              challengePoints += pointsEarned;
              updateLeaderboardChallenge(pointsEarned);
              adjustSpeedForNextLevel();
              showPointsPopup(pointsEarned);

              challengeAttempts = 3;
              lastCompleteRun = null;
            } else {
              challengeAttempts--;
              if (challengeAttempts > 0) {
                setMainLabel(`Try again! ${4 - challengeAttempts}nd attempt!`);
                setTimeout(() => {
                  clearCanvas();
                  drawTrack(currentTrack);
                  updateWeatherForChallenge();
                  setMainLabel(`Beat this time: ${formatTime(challengeBestTime)}`);
                }, 1500);
              } else {
                setMainLabel("Failed! Retry!");
                setTimeout(() => {
                  showChallengeEndOverlay("Well done!");
                  isChallengeMode = false;
                }, 1500);
              }
            }
          }, 2000);
        } else {
          // Modalità normale
          setMainLabel(
            `⏰${formatTime(finalTime)}${
              outPenaltyTotal > 0 ? `<span style="color:red;"> (+${outPenaltyTotal.toFixed(2)})</span>` : ""
            }`
          );
          updateBestTimes(finalTime, lastCompleteRun, currentPlayerName);

          if (currentTrackName !== "") {
            savedTracks[currentTrackName].bestTimes = bestTimes;
            storeSavedTracks();
          }
        }

        if (!isChallengeMode) {
          setTimeout(() => {
            resetRun();
          }, 1000);
        }
      }

      /* Mostra la schermata di fine Challenge */
      function showChallengeEndOverlay(failReason = "") {
        const overlay = document.getElementById("challengeEndOverlay");
        const content = document.getElementById("challengeEndContent");

        let titleText = currentTitleUnlocked ? currentTitleUnlocked : "(no title unlocked)";
        let reasonText = failReason ? `<p style="color:red;">${failReason}</p>` : "";

        let html = `
          <h2>Challenge End</h2>
          ${reasonText}
          <p>You reached <strong>Level #${currentLevel}</strong></p>
          <p>Your total score: <strong>${challengePoints}</strong></p>
          <p>Title unlocked:<br> <strong>${titleText}</strong></p>
          <hr>`;

        if (challengePoints > 0) {
          if (currentChallengeSaveName) {
            html += `<p>Your game has been saved as:<br><strong>${currentChallengeSaveName}</strong></p>`;
          } else {
            html += `<div style="margin:10px 0;">
               <label style="display:block; margin-bottom:10px;">Save your game:</label>
               <input type="text" id="challengeSaveName" placeholder="Enter a name" maxlength="6" />
               <button id="challengeSaveBtn" style="margin-left:5px;">Save</button>
             </div>`;
          }
          html += `<div id="challengeSavedGamesList" style="margin:10px 0;"></div>
           <hr>`;
        }

        html += `
          <div class="centered-button">
            <button id="challengeNewGameBtn" class="play-button">New Game</button>
          </div>
          <button id="challengeQuitBtn" style="margin:10px;">Quit</button>`;

        content.innerHTML = html;
        overlay.classList.remove("hidden");

        document.getElementById("challengeNewGameBtn").addEventListener("click", function() {
          currentChallengeSaveName = "";
          resetChallenge();
          overlay.classList.add("hidden");
          startNewChallenge();
        });

        document.getElementById("challengeQuitBtn").addEventListener("click", function() {
          currentChallengeSaveName = "";
          isChallengeMode = false;
          challengeAttempts = 0;
          setMainLabel("⏰1'00\"000'''");
          toggleButtonState(false);
          resetRun();
          overlay.classList.add("hidden");
        });

        if (challengePoints > 0 && currentChallengeSaveName) {
          saveChallengeGame(currentChallengeSaveName, {
            level: currentLevel,
            points: challengePoints,
            title: currentTitleUnlocked,
            attemptsLeft: challengeAttempts,
            speed: speed
          });
          alert("Game saved automatically as: " + currentChallengeSaveName);
        } else if (challengePoints > 0) {
          document.getElementById("challengeSaveBtn").addEventListener("click", () => {
            let name = (document.getElementById("challengeSaveName").value || "").trim();
            if (!name) {
              alert("Please enter a valid name for your saved game.");
              return;
            }
            saveChallengeGame(name, {
              level: currentLevel,
              points: challengePoints,
              title: currentTitleUnlocked,
              attemptsLeft: challengeAttempts,
              speed: speed
            });
            currentChallengeSaveName = name;
            renderSavedGamesList();
            document.getElementById("challengeSaveName").value = "";
          });
        }

        renderSavedGamesList();
      }

      /* Funzione che disegna la lista dei salvataggi Challenge */
      function renderSavedGamesList() {
        const listDiv = document.getElementById("challengeSavedGamesList");
        if (!listDiv) return;
        listDiv.innerHTML = "";
        let saves = getChallengeSaves();
        let keys = Object.keys(saves);

        if (keys.length === 0) {
          listDiv.innerHTML = "<p>No saved games.</p>";
          return;
        }

        let label = document.createElement("p");
        label.innerHTML = "<strong>Saved games:</strong>";
        listDiv.appendChild(label);

        keys.forEach((name) => {
          let data = saves[name];
          let container = document.createElement("div");
          container.style.display = "flex";
          container.style.alignItems = "center";
          container.style.justifyContent = "space-between";
          container.style.margin = "5px 0";

          let span = document.createElement("span");
          span.classList.add("saved-item-text");
          span.textContent = `${name} (Lv ${data.level}, ${data.points} pts)`;
          span.addEventListener("click", () => {
            onLoadSavedGame(name);
          });

          let delBtn = document.createElement("button");
          delBtn.className = "deleteBtn";
          delBtn.textContent = "Delete";
          delBtn.addEventListener("click", () => {
            onDeleteSavedGame(name);
          });

          container.appendChild(span);
          container.appendChild(delBtn);
          listDiv.appendChild(container);
        });
      }

      /* Funzione chiamata quando si clicca su un salvataggio Challenge nella lista */
      function onLoadSavedGame(name) {
        if (loadChallengeGame(name)) {
          currentChallengeSaveName = name;
          alert("Loaded saved game: " + name);
          document.getElementById("challengeEndOverlay").classList.add("hidden");
          startNewChallenge();
        } else {
          alert("Error: saved game not found.");
        }
      }

      /* Funzione chiamata quando si clicca "Delete" su un salvataggio Challenge */
   function onDeleteSavedGame(name) {
  if (confirm(`Are you sure you want to delete '${name}'?`)) {
    deleteChallengeGame(name);
    // Ricarica subito il contenuto del popup in modo che l’elemento sparisca
    checkSavedChallengeGames();
  }
}

      /* Controlla la presenza di salvataggi Challenge e mostra l'overlay */
      function checkSavedChallengeGames() {
        let saves = getChallengeSaves();
        let keys = Object.keys(saves);
        let overlay = document.getElementById("challengeEndOverlay");
        let content = document.getElementById("challengeEndContent");

        if (keys.length > 0) {
          let html = `
            <h2>Load or Start a New Challenge!</h2>
            <p><strong>Saved Games:</strong></p>
            <ul style="list-style: none; padding:0;">`;
          keys.forEach((name) => {
            let data = saves[name];
            html += `
              <li style="margin-bottom:8px;">
                <span class="saved-item-text" onclick="onLoadSavedGame('${name}')">
                  ${name} (Lv ${data.level}, ${data.points} pts)
                </span>
                <button class="deleteBtn" onclick="onDeleteSavedGame('${name}')">Delete</button>
              </li>`;
          });
          html += `</ul>
            <hr>
            <button id="challengeNewGameBtn" class="play-button">New Game</button>
            <button id="challengeQuitBtn" style="margin:10px;">Quit</button>`;
          content.innerHTML = html;

          document.getElementById("challengeNewGameBtn").addEventListener("click", () => {
            resetChallenge();
            overlay.classList.add("hidden");
            startNewChallenge();
          });
          document.getElementById("challengeQuitBtn").addEventListener("click", () => {
            isChallengeMode = false;
            challengeAttempts = 0;
            setMainLabel("⏰0'00\"000'''");
            toggleButtonState(false);
            resetRun();
            document.getElementById("challengeEndOverlay").classList.add("hidden");
          });
        } else {
          content.innerHTML = `
            <h2>Start the Challenge!</h2>
            <p>Try to beat the best time and level up!</p>
            <hr>
            <button id="challengeNewGameBtn" class="play-button">New Game</button>
            <button id="challengeQuitBtn" style="margin:10px;">Quit</button>`;
          document.getElementById("challengeNewGameBtn").addEventListener("click", () => {
            resetChallenge();
            overlay.classList.add("hidden");
            startNewChallenge();
          });
          document.getElementById("challengeQuitBtn").addEventListener("click", () => {
            isChallengeMode = false;
            challengeAttempts = 0;
            setMainLabel("⏰0'00\"000'''");
            toggleButtonState(false);
            overlay.classList.add("hidden");
          });
        }
        overlay.classList.remove("hidden");
      }

      /* Mostra popup di conferma con messaggio personalizzato */
      function showConfirmPopup(message, onConfirm, onCancel) {
        const overlay = document.createElement("div");
        overlay.className = "overlay";

        const content = document.createElement("div");
        content.className = "overlay-content";
        content.innerHTML = `
          <button id="closePopup" style="
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: #8fa2f7;
            font-size: 14px;
            padding: 5px 10px;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;">X</button>
          <h2>Attention!</h2>
          <p class="slide-content">${message}</p>
          <div class="popup-button-container" style="margin-top: 15px;">
            <button class="nav-button" id="popupConfirmButton">OK</button>
          </div>
        `;

        overlay.appendChild(content);
        document.body.appendChild(overlay);

        document.getElementById("popupConfirmButton").addEventListener("click", function () {
          document.body.removeChild(overlay);
          if (onConfirm) onConfirm();
        });
        document.getElementById("closePopup").addEventListener("click", function () {
          document.body.removeChild(overlay);
          if (onCancel) onCancel();
        });
      }

      function showLeaderboardPopup() {
        const overlay = document.createElement("div");
        overlay.className = "overlay";

        const content = document.createElement("div");
        content.className = "overlay-content";
        content.innerHTML = `
          <h2>Game Over!</h2>
          <p>You reached <strong>Level #${currentLevel}</strong>.</p>
          <p>Your total score: <strong>${challengePoints}</strong></p>
          <button class="play-button">Play Again</button>
        `;
        content.querySelector("button").addEventListener("click", () => {
          document.body.removeChild(overlay);
          resetChallenge();
          toggleChallengeMode();
          startNewChallenge();
        });
        overlay.appendChild(content);
        document.body.appendChild(overlay);
      }

      /* Riduce la velocità (speed) per il prossimo livello, non sotto 1.0 */
      function adjustSpeedForNextLevel() {
        speed = Math.max(1.0, speed - speedDecrement);
      }

      /* Mostra un popup con i punti guadagnati al termine del livello */
      function showPointsPopup(points) {
        const overlay = document.createElement("div");
        overlay.className = "overlay";

        const content = document.createElement("div");
        content.className = "overlay-content";

        let newTitle = getTitleForLevel(currentLevel);
        let isNewTitleUnlocked = false;
        if (newTitle !== "" && newTitle !== currentTitleUnlocked) {
          currentTitleUnlocked = newTitle;
          isNewTitleUnlocked = true;
        }

        content.innerHTML = `
          <h2>Level #${currentLevel} Complete!</h2>
          <p>You earned <strong>${points}</strong> points!</p>
          <p>Total Points: <strong>${challengePoints}</strong></p>
          <div id="titleArea" style="margin: 10px 0;"></div>
          <button class="play-button">Next Level</button>
        `;

        const titleArea = content.querySelector("#titleArea");
        if (isNewTitleUnlocked) {
          let unlockMsg = document.createElement("p");
          unlockMsg.style.color = "blue";
          unlockMsg.style.fontWeight = "bold";
          unlockMsg.textContent = "You've unlocked a new title!";
          titleArea.appendChild(unlockMsg);

          let imgName = getTitleImageForLevel(currentLevel);
          if (imgName !== "") {
            let img = document.createElement("img");
            img.src = imgName;
            img.alt = "Current Title";
            img.style.width = "200px";
            img.style.height = "auto";
            img.style.display = "block";
            img.style.margin = "5px auto";
            titleArea.appendChild(img);
          }
        } else {
          let currentTitleText = currentTitleUnlocked
            ? `Your current title:<br><b>${currentTitleUnlocked}</b>`
            : "No title unlocked yet.";
          let p = document.createElement("p");
          p.style.margin = "5px 0";
          p.innerHTML = currentTitleText;
          titleArea.appendChild(p);
        }

        content.querySelector("button").addEventListener("click", () => {
          document.body.removeChild(overlay);
          currentLevel++;
          adjustSpeedForNextLevel();
          startNewChallenge();
        });

        overlay.appendChild(content);
        document.body.appendChild(overlay);
      }

      /* Fallimento Run */
      function failRun(msg) {
        drawing = false;
        didFinishOrFail = true;

        if (pointsPath.length > 1) {
          lastCompleteRun = JSON.parse(JSON.stringify(pointsPath));
        }
        window.lastFinalTime = 0; 

        setMainLabel(msg);

        if (isChallengeMode) {
          challengeAttempts--;
          if (challengeAttempts > 0) {
            setTimeout(() => {
              setMainLabel(`Try again! ${4 - challengeAttempts}nd attempt!`);
              setTimeout(() => {
                clearCanvas();
                drawTrack(currentTrack);
                updateWeatherForChallenge();
                setMainLabel(`Beat this time: ${formatTime(challengeBestTime)}`);
              }, 1500);
            }, 1500);
          } else {
            setTimeout(() => {
              showChallengeEndOverlay("You failed the Challenge!");
            }, 1500);
          }
        } else {
          setTimeout(() => {
            resetRun();
          }, 1000);
        }
      }

      /* Reset parametri Challenge */
      function resetChallenge() {
        currentLevel = 1;
        speed = 3.5;
        challengePoints = 0;
      }

      function showLeaderboardPopupWithPlayAgain() {
        const overlay = document.createElement("div");
        overlay.className = "overlay";

        const content = document.createElement("div");
        content.className = "overlay-content";

        let titleText = currentTitleUnlocked ? currentTitleUnlocked : "";
        content.innerHTML = `
          <h2>Challenge Failed</h2>
          <p>You reached <br><strong>${titleText}<br>Level #${currentLevel}</strong>
             <br>with <strong>${challengePoints}</strong> points.</p>
          <button class="play-button">Play Again</button>
        `;
        content.querySelector("button").addEventListener("click", () => {
          document.body.removeChild(overlay);
          resetChallenge();
          toggleChallengeMode();
        });
        overlay.appendChild(content);
        document.body.appendChild(overlay);
      }

      /* Aggiorna la leaderboard Challenge */
      function updateLeaderboardChallenge(pointsEarned) {
        leaderboard.push({ points: challengePoints, date: new Date() });
        leaderboard.sort((a, b) => b.points - a.points);
        if (leaderboard.length > 10) leaderboard.length = 10;
      }

      /* Calcola la distanza totale percorsa dall'array di punti */
      function calculateDistance(arr) {
        let tot = 0;
        for (let i = 1; i < arr.length; i++) {
          let dx = arr[i].x - arr[i - 1].x;
          let dy = arr[i].y - arr[i - 1].y;
          tot += Math.hypot(dx, dy);
        }
        return tot;
      }

      /* Calcola tempo finale con penalità */
      function calculateFinalTime(ms, dist) {
        let s = ms / 1000;
        let penalty = PENALTY_WEIGHT * (dist / PATH_LENGTH_SCALING);
        return 60 + s + penalty;
      }

      /* Formatta i secondi in mm'ss"ms''' */
      function formatTime(sec) {
        let m = Math.floor(sec / 60);
        let r = (sec % 60).toFixed(3);
        return `${m}'${r.replace(".", '"')}'''`;
      }

      /* Aggiorna la Top 5 con un nuovo tempo */
      function updateBestTimes(time, replayData, playerName = "Anonymous") {
        bestTimes = bestTimes.filter(entry => entry.time !== time);

        let result = { name: playerName, time, replay: replayData };
        bestTimes.push(result);
        bestTimes.sort((a, b) => a.time - b.time);
        if (bestTimes.length > 5) bestTimes.length = 5;

        if (bestTimes.length > 0 && bestTimes[0].time === time) {
          infoLine.classList.add("record");
          setTimeout(() => {
            infoLine.classList.remove("record");
          }, 2000);
        }
      }

      /* Attiva/Disattiva Challenge Mode */
      function toggleChallengeMode() {
        if (isChallengeMode) {
          showConfirmPopup(
            "Are you sure you want to quit Challenge Mode?",
            function () {
              isChallengeMode = false;
              challengeAttempts = 0;
              setMainLabel("⏰0'00\"000'''");
              toggleButtonState(false);
            },
            function () {
              console.log("Quit Challenge Mode canceled");
            }
          );
        } else {
          document.getElementById("challengeIntroOverlay").classList.remove("hidden");
          lastCompleteRun = null;
          window.lastFinalTime = 0;
        }
      }

      document.getElementById("challengeButton").addEventListener("click", toggleChallengeMode);

      /* Disattiva/attiva alcuni pulsanti */
      function toggleButtonState(disable) {
        const buttonsToDisable = [
          document.getElementById("chronoButton"),
          document.getElementById("sameTrack"),
          document.getElementById("quit"),
          document.getElementById("saveResultBtn"),
          document.getElementById("viewBtn")
        ];
        buttonsToDisable.forEach((button) => {
          if (disable) {
            button.disabled = true;
            button.classList.add("button-disabled");
          } else {
            button.disabled = false;
            button.classList.remove("button-disabled");
          }
        });
      }

      /* Avvia una nuova Challenge */
      function startNewChallenge() {
        if (isGeneratingChallenge) return;
        isGeneratingChallenge = true;

        adjustSpeedForNextLevel();
        currentTrack = createTrack();
        drawTrack(currentTrack);
        let numTrees = currentTrack.trees.length;
        let factor = 1.0;
        if (numTrees === 6) {
          factor = 1.10;
        } else if (numTrees === 7) {
          factor = 1.20;
        } else if (numTrees >= 8) {
          factor = 1.30;
        }
        updateWeatherForChallenge();
        let idealLength = calculateIdealPath(currentTrack.gates);
        if (isNaN(idealLength) || idealLength <= 0) {
          idealLength = 300;
        }
        idealLength *= factor;
        challengeBestTime = calculateFinalTime(
          idealLength * 6.5 * (speed / baseSpeed),
          idealLength
        );
        if (isNaN(challengeBestTime) || challengeBestTime <= 0) {
          challengeBestTime = 66.542;
        }
        challengeAttempts = 3;
        setMainLabel(`Beat this time: ${formatTime(challengeBestTime)}`);
        setTimeout(() => {
          isGeneratingChallenge = false;
        }, 500);
      }

      /* Calcola la "lunghezza ideale" della pista guardando i gates */
      function calculateIdealPath(gates) {
        let length = 0;
        for (let i = 1; i < gates.length; i++) {
          let dx = gates[i].x - gates[i - 1].x;
          let dy = gates[i].y - gates[i - 1].y;
          length += Math.hypot(dx, dy);
        }
        return length;
      }

      /* Aggiorna lo stato meteo per la Challenge */
      function updateWeatherForChallenge() {
        weatherState = chooseWeatherState(weatherState);
        applyWeatherState(weatherState);
        if (!snowLocked) {
          if (showSnow) {
            snowCanvas.classList.remove("hidden");
            initSnow();
            updateSnow();
          } else {
            snowCanvas.classList.add("hidden");
          }
        }
      }

      /* Replay di una traiettoria salvata */
      function replayTrajectory(customPoints) {
        let container = document.getElementById("gameContainer");
        let originalBackground = container.style.background;
        container.style.background = '#c4d3fc url("sfondoreplay.png") no-repeat center center';
        container.style.backgroundSize = "cover";

        let rp = customPoints && customPoints.length >= 2 ? customPoints : lastCompleteRun;
        let replayTime = window.lastFinalTime;

        if (customPoints && bestTimes.length > 0) {
          let bestReplay = bestTimes.find(entry => entry.replay === customPoints);
          if (bestReplay) {
            replayTime = bestReplay.time;
          }
        }

        setMainLabel(`⏰${formatTime(replayTime)}`);
        if (!rp || rp.length < 2) {
          showTemporaryMessage("No run to replay!", 1000);
          setTimeout(() => {
            setMainLabel("⏰0'00\"000'''");
            container.style.background = originalBackground;
          }, 1000);
          return;
        }

        clearCanvas();
        drawStartPoint();
        drawFinishArea();
        drawGates(gates);
        drawTrees(trees);

        let i = 0;
        function step() {
          if (i >= rp.length - 1) {
            setTimeout(() => {
              clearCanvas();
              drawTrack(currentTrack);
              container.style.background = originalBackground;
              setMainLabel("⏰0'00\"000'''");
            }, 1000);
            return;
          }
          ctx.beginPath();
          ctx.moveTo(rp[i].x, rp[i].y);
          ctx.lineTo(rp[i + 1].x, rp[i + 1].y);
          ctx.strokeStyle = "#a4b8eb";
          ctx.lineWidth = (2 / 520) * canvas.height;
          ctx.stroke();

          let dt = rp[i + 1].t - rp[i].t;
          i++;
          setTimeout(step, dt);
        }
        setTimeout(step, 0);
      }

      /* Gestione click bottoni principali */
      sameTrackButton.addEventListener("click", () => {
        snowLocked = !snowLocked;
        if (snowLocked) {
          sameTrackButton.style.opacity = "0.5";
          showTemporaryMessage("Snow locked", 1000);
        } else {
          sameTrackButton.style.opacity = "1";
          showTemporaryMessage("Snow enabled", 1000);
        }
        resetRun();
      });

      replayButton.addEventListener("click", () => {
        if (lastCompleteRun && lastCompleteRun.length >= 2) {
          replayTrajectory(lastCompleteRun);
        } else {
          showTemporaryMessage("No run to replay!", 1000);
        }
      });

      quitButton.addEventListener("click", () => {
        isChallengeMode = false;
        challengeAttempts = 0;
        setMainLabel("⏰0'00\"000'''");
        toggleButtonState(false);

        currentTrack = createTrack();
        bestTimes = [];
        currentTrackName = "";
        lastCompleteRun = null;

        clearCanvas();
        drawTrack(currentTrack);
      });

      chronoButton.addEventListener("click", () => {
        updateLeaderboard();
        chronoOverlay.classList.remove("hidden");
      });

      closeChronoOverlay.addEventListener("click", () => {
        chronoOverlay.classList.add("hidden");
      });

      viewBtn.addEventListener("click", () => {
        updateSavedTracksList();
        viewOverlay.classList.remove("hidden");
      });

      closeViewOverlay.addEventListener("click", () => {
        viewOverlay.classList.add("hidden");
      });

      saveResultBtn.addEventListener("click", () => {
        if (isChallengeMode) {
          alert("Save Result is disabled in Challenge Mode.");
          return;
        }
        saveResultOverlay.classList.remove("hidden");
      });

      closeSaveResultOverlay.addEventListener("click", () => {
        saveResultOverlay.classList.add("hidden");
      });

      /* Intro Challenge -> Start Challenge */
      document
        .getElementById("closeChallengeIntroOverlay")
        .addEventListener("click", () => {
          document.getElementById("challengeIntroOverlay").classList.add("hidden");
          isChallengeMode = true;
          challengeAttempts = 3;
          toggleButtonState(true);
          checkSavedChallengeGames();
        });

      /* Pulsante X in alto a sinistra dell’intro Challenge */
      document.getElementById("closeChallengeIntroButton").addEventListener("click", function() {
        document.getElementById("challengeIntroOverlay").classList.add("hidden");
      });

      /* Pulsante "Save Result" nel popup */
      document.getElementById("saveResultConfirmBtn").addEventListener("click", () => {
        let name = document.getElementById("resultNameInput").value.trim();
        if (name === "") {
          alert("Enter your name!");
          return;
        }
        if (typeof window.lastFinalTime !== "number" || window.lastFinalTime === 0) {
          alert("No valid time recorded!");
          return;
        }
        currentPlayerName = name;
        localStorage.setItem("currentPlayerName", name);
        updateBestTimes(window.lastFinalTime, lastCompleteRun, name);
        saveResultOverlay.classList.add("hidden");
        updateLeaderboard();
      });

      /* Funzione per ripristinare lo stato pre-run */
      function resetRun() {
        drawing = false;
        didFinishOrFail = false;
        pointsPath = [];
        setMainLabel("⏰0'00\"000'''");
        clearCanvas();
        drawTrack(currentTrack);
        globalWind = Math.random() * 1 - 0.5;
        weatherState = chooseWeatherState(weatherState);
        applyWeatherState(weatherState);

        if (snowLocked) {
          snowCanvas.classList.add("hidden");
        } else {
          if (showSnow) {
            snowCanvas.classList.remove("hidden");
            initSnow();
            updateSnow();
          } else {
            snowCanvas.classList.add("hidden");
          }
        }
      }

      /* Aggiorna la lista Top 5 */
      function updateLeaderboard() {
        let lb = document.getElementById("leaderboardList");
        lb.innerHTML = "";
        bestTimes.forEach((entry, i) => {
          let li = document.createElement("li");
          if (i === 0) {
            li.innerHTML = `${entry.name} - ${formatTime(entry.time)} <img src="replay.png" alt="Replay" style="width:20px; height:20px; cursor:pointer; transform: translateY(3px);" title="Click to watch the best replay">`;
            li.style.fontWeight = "bold";
            li.addEventListener("click", () => {
              chronoOverlay.classList.add("hidden");
              replayTrajectory(entry.replay);
            });
          } else {
            li.textContent = `${entry.name} - ${formatTime(entry.time)}`;
          }
          lb.appendChild(li);
        });
      }

      /* Gestione LocalStorage piste salvate */
      const LS_KEY = "skiSolo_savedTracks";

      /* Salvataggi partite Challenge */
      const CHALLENGE_SAVES_KEY = "skiSolo_challengeSaves";
      function getChallengeSaves() {
        let raw = localStorage.getItem(CHALLENGE_SAVES_KEY);
        if (!raw) return {};
        try {
          return JSON.parse(raw);
        } catch (e) {
          return {};
        }
      }
      function storeChallengeSaves(savesObj) {
        localStorage.setItem(CHALLENGE_SAVES_KEY, JSON.stringify(savesObj));
      }
      function saveChallengeGame(name, data) {
        let saves = getChallengeSaves();
        saves[name] = data;
        storeChallengeSaves(saves);
        renderSavedGamesList();
        document.getElementById("challengeSaveName").style.display = "none";
        document.getElementById("challengeSaveBtn").style.display = "none";
      }
      function deleteChallengeGame(name) {
        let saves = getChallengeSaves();
        if (saves[name]) {
          delete saves[name];
          storeChallengeSaves(saves);
        }
      }
      function loadChallengeGame(name) {
        let saves = getChallengeSaves();
        if (!saves[name]) return false;
        let data = saves[name];
        currentLevel = data.level;
        challengePoints = data.points;
        currentTitleUnlocked = data.title;
        challengeAttempts = data.attemptsLeft;
        speed = data.speed;
        return true;
      }

      /* Caricamento e salvataggio piste personalizzate */
      function loadSavedTracks() {
        let saved = localStorage.getItem(LS_KEY);
        if (saved) {
          try {
            savedTracks = JSON.parse(saved);
          } catch (e) {
            savedTracks = {};
          }
        } else {
          savedTracks = {};
        }
      }
      function storeSavedTracks() {
        localStorage.setItem(LS_KEY, JSON.stringify(savedTracks));
      }

      /* Aggiorna la lista delle piste salvate nel popup */
      function updateSavedTracksList() {
        loadSavedTracks();
        let listDiv = document.getElementById("savedTracksList");
        listDiv.innerHTML = "";
        for (let name in savedTracks) {
          let container = document.createElement("div");
          container.style.display = "flex";
          container.style.alignItems = "center";
          container.style.justifyContent = "space-between";
          container.style.margin = "5px 0";

          let span = document.createElement("span");
          span.textContent = name;
          span.classList.add("saved-item-text");
          span.addEventListener("click", () => {
            let saved = savedTracks[name];
            currentTrack = saved.track;
            bestTimes = saved.bestTimes || [];
            currentTrackName = name;
            resizeCanvas();
            resetRun();
            viewOverlay.classList.add("hidden");
          });

          let delBtn = document.createElement("button");
          delBtn.textContent = "Delete";
          delBtn.className = "deleteBtn";
          delBtn.addEventListener("click", () => {
            if (confirm(`Are you sure you want to delete the track "${name}"?`)) {
              delete savedTracks[name];
              storeSavedTracks();
              updateSavedTracksList();
            }
          });

          container.appendChild(span);
          container.appendChild(delBtn);
          listDiv.appendChild(container);
        }
      }

      document.getElementById("saveTrackBtn").addEventListener("click", () => {
        let trackName = document.getElementById("trackNameInput").value.trim();
        if (trackName === "") {
          alert("Enter a track name.");
          return;
        }
        savedTracks[trackName] = { track: currentTrack, bestTimes: [...bestTimes] };
        currentTrackName = trackName;
        storeSavedTracks();
        alert("Track saved!");
        updateSavedTracksList();
        viewOverlay.classList.add("hidden");
      });

      /* Tutorial */
      function renderTutorial() {
        let slide = tutorialSlides[currentTutorialIndex];
        tutorialContent.innerHTML = `<h2>${slide.title}</h2><p>${slide.content}</p>`;
        tutorialDots.innerHTML = "";
        tutorialSlides.forEach((s, i) => {
          let d = document.createElement("div");
          d.className = "dot" + (i === currentTutorialIndex ? " active" : "");
          d.addEventListener("click", () => {
            currentTutorialIndex = i;
            renderTutorial();
          });
          tutorialDots.appendChild(d);
        });
        tutorialStart.style.display = "inline-block";
        tutorialPrev.style.display = "inline-block";
        tutorialNext.style.display = "inline-block";
      }

      tutorialPrev.addEventListener("click", () => {
        if (currentTutorialIndex > 0) {
          currentTutorialIndex--;
          renderTutorial();
        }
      });
      tutorialNext.addEventListener("click", () => {
        if (currentTutorialIndex < tutorialSlides.length - 1) {
          currentTutorialIndex++;
          renderTutorial();
        }
      });
      tutorialStart.addEventListener("click", () => {
        tutorialOverlay.classList.add("hidden");
        startGame();
      });

      function startGame() {
        loadSavedTracks();
        currentTrack = createTrack();
        bestTimes = [];
        currentTrackName = "";
        resizeCanvas();
        resetRun();
        drawTrack(currentTrack);
      }

      renderTutorial();

      /* Pulsante Home per tornare all'index */
      document.getElementById("homeBtn").addEventListener("click", function () {
        showConfirmPopup(
          "Return to home to play the World Cup?",
          function () {
            location.href = "index.html";
          },
          function () {
            console.log("Home action canceled");
          }
        );
      });

      /* Al caricamento finestra */
      window.onload = function () {
        resizeCanvas();
      };
    </script>

    <div class="bottom-space"></div>
  </body>
</html>
